//    This code is copyright 2001 by G5 Software.
//    Any unauthorized usage, either in part or in whole of this code
//    is strictly prohibited. Violators WILL be prosecuted to the
//    maximum extent allowed by law.
//
//-------------------------------------------------------------------


//    миномёты и гаубицы
class HowitzerGroup_1 extends GroupBombard
{
    Array m_TargetNavPoint1 = ["NavPoint_XRay_Fire_1_1A", "NavPoint_XRay_Fire_1_2A", "NavPoint_XRay_Fire_1_3A", "NavPoint_XRay_Fire_1_4A", "NavPoint_XRay_Fire_1_5A", "NavPoint_XRay_Fire_1_6A"];
    Array m_TargetNavPoint2 = ["NavPoint_XRay_Fire_1_1B", "NavPoint_XRay_Fire_1_2B", "NavPoint_XRay_Fire_1_3B", "NavPoint_XRay_Fire_1_4B", "NavPoint_XRay_Fire_1_5B", "NavPoint_XRay_Fire_1_6B"];
    Array m_TargetNavPoint3 = ["NavPoint_XRay_Fire_1_1C", "NavPoint_XRay_Fire_1_2C", "NavPoint_XRay_Fire_1_3C", "NavPoint_XRay_Fire_1_4C", "NavPoint_XRay_Fire_1_5C", "NavPoint_XRay_Fire_1_6C"];
    Array m_TargetNavPoint4 = ["NavPoint_XRay_Fire_1_1M", "NavPoint_XRay_Fire_1_2M", "NavPoint_XRay_Fire_1_3M", "NavPoint_XRay_Fire_1_4M", "NavPoint_XRay_Fire_1_5M", "NavPoint_XRay_Fire_1_6M"];

    void Init()
    {
      //disabling behavior
      ForEachUnitTask("ActivateBehavior", [false]);

      GroupBombard::Init();
    }

    event void EnableTrueFire(boolean _On)
    {
      ForEachUnitTask("ActivateBehavior", [_On]);
      if (true == _On)
        sendEvent(0.0, getIdentificator(this), "FirePoint", []);
    }

    event void FireToMotarPosition()
    {
        //activating behavior
        ForEachUnitTask("ActivateBehavior", [true]);
        //logWarning("[FireToMotarPosition] for group witn ID=" + getIdentificator(user)    );
        clearEventsForObject(getIdentificator(this));

        //logWarning("[FireToMotarPosition] m_TargetNavPoint4[]=" + new String(m_TargetNavPoint4));
        for ( int i = 0; i < m_Units.size(); i++)
            InvokeUnitTaskFunction(m_Units[i],"SetFireStyle_SpecialFire",[m_TargetNavPoint4[i] ]);
    }
}

class HowitzerGroup_2 extends GroupBombard
{
    Array m_TargetNavPoint1 = ["NavPoint_XRay_Fire_2_1A", "NavPoint_XRay_Fire_2_2A", "NavPoint_XRay_Fire_2_3A", "NavPoint_XRay_Fire_2_4A", "NavPoint_XRay_Fire_2_5A", "NavPoint_XRay_Fire_2_6A"];
    Array m_TargetNavPoint2 = ["NavPoint_XRay_Fire_2_1B", "NavPoint_XRay_Fire_2_2B", "NavPoint_XRay_Fire_2_3B", "NavPoint_XRay_Fire_2_4B", "NavPoint_XRay_Fire_2_5B", "NavPoint_XRay_Fire_2_6B"];
    Array m_TargetNavPoint3 = ["NavPoint_XRay_Fire_2_1C", "NavPoint_XRay_Fire_2_2C", "NavPoint_XRay_Fire_2_3C", "NavPoint_XRay_Fire_2_4C", "NavPoint_XRay_Fire_2_5C", "NavPoint_XRay_Fire_2_6C"];

    void Init()
    {
      //disabling behavior
      ForEachUnitTask("ActivateBehavior", [false]);

      GroupBombard::Init();
    }

    event void EnableTrueFire(boolean _On)
    {
      ForEachUnitTask("ActivateBehavior", [_On]);
      if (true == _On)
        sendEvent(0.0, getIdentificator(this), "FirePoint", []);
    }
}

// fireEvent(0.0, [], "Fire", [true]);
class AmericanXRayMotarGroup    extends GroupBombard
{
    Array m_TargetNavPoint1 = ["NavPoint_XRay_American_1", "NavPoint_XRay_American_2"];

    void Init()
    {
        SetImmortalMode(true);
//     Стрелять по низкой траектории    setHighTrajectory(false);
         for ( int i = 0; i < m_Units.size(); i++)
         {
             Component Behavior = GetUnitBehavior(m_Units[i]);
             if ( Behavior != null)
             {
                 Behavior.setHighTrajectory(false);
             }
         }
    }

    void OnEnemyTargeted(Component _UnitAlerted)
    {
        String TargetedUnit = _UnitAlerted.GetTargetedEnemy();
        //sendEvent(0.0, getIdentificator(user), "Fire", []);

        //logWarning("[OnEnemyTargeted] Unit: with ID="+ _UnitAlerted.GetName() + " see enemy with ID=" +_UnitAlerted.GetTargetedEnemy());
    }

    event void Fire()
    {
        Array EnemyList = GetEnemyListOnGroupRadar();

        //logWarning("[Fire] Group with ID="+ getIdentificator(user)+ " shoot at:");
        //logWarning( new String(EnemyList));

        sendEvent(0.0, getIdentificator(user), "ShootRand", [ true, EnemyList]);
        sendEvent(2.0, getIdentificator(user), "ShootRand", [ false, EnemyList]);
        sendEvent(5.0, getIdentificator(user), "Fire", []);
    }

}

class VietnameseXRayMotarGroup  extends GroupBombard
{
    Array m_TargetNavPoint1 = ["NavPoint_XRay_Vietnamese_1A", "NavPoint_XRay_Vietnamese_2A"];
    Array m_TargetNavPoint2 = ["NavPoint_XRay_Vietnamese_1B", "NavPoint_XRay_Vietnamese_2B"];
    Array m_TargetNavPoint3 = ["NavPoint_XRay_Vietnamese_1C", "NavPoint_XRay_Vietnamese_2C"];
    Array m_TargetNavPoint4 = ["NavPoint_XRay_Vietnamese_1D", "NavPoint_XRay_Vietnamese_2D"];
    Array m_TargetNavPoint5 = ["NavPoint_XRay_Vietnamese_1E", "NavPoint_XRay_Vietnamese_2E"];

    int m_CounterFirePlace = 1;

    event void FirePoint()
    {
        //logWarning("[FirePoint] for group with ID="+ getIdentificator(user) );
        if (m_CounterFirePlace == 6)
                m_CounterFirePlace = 1;

        if (m_CounterFirePlace == 1)
                Array ArrayID = m_TargetNavPoint1;
        else if (m_CounterFirePlace == 2)
                Array ArrayID = m_TargetNavPoint2;
        else if (m_CounterFirePlace == 3)
                Array ArrayID = m_TargetNavPoint3;
        else if (m_CounterFirePlace == 4)
                Array ArrayID = m_TargetNavPoint4;
        else if (m_CounterFirePlace == 5)
                Array ArrayID = m_TargetNavPoint5;

        //logWarning("[FirePoint] ArrayID=" + new String(ArrayID));
        //logWarning("[FirePoint] m_CounterFirePlace=" + new String(m_CounterFirePlace));
        Array m_Units = GetUnitsList();
        for ( int i = 0; i < m_Units.size(); i++)
        {
            //logWarning("[FirePoint] for unit with ID="+ m_Units[i]+ " target navpoint ID="+ ArrayID[i]);
            InvokeUnitTaskFunction(m_Units[i],"SetFireStyle_SpecialFire",[ArrayID[i] ]);
        }

        sendEvent( 20.0, getIdentificator(user), "FirePoint", []);
        m_CounterFirePlace = m_CounterFirePlace + 1;
    }
}

class VietnameseXRayMotarTask extends CBaseAITask
{
  boolean isImmortal = true;
    void Init()
    {
      GetSelf().GetStateControl().SetImmortalMode(true);
    }

    event void CheatOnHitByEnemy()
    {
      Component _Mortar = GetUnitTask("Vietnamese_XRayMortar_1");
      GetSelf().GetStateControl().SetImmortalMode(false);
      //_Mortar.OnHitByEnemy("MainPlayerUnit");
      sendEvent(randnum(10), getIdentificator(user), "DestroyObject", []);
      logWarning("CheatOnHitByEnemy");
    }

    void OnHitByEnemy(String _EnemyID)
    {

        logWarning(" Unit with ID " + getIdentificator(user) + " OnHitByEnemy    with ID=" + _EnemyID);
        if ( _EnemyID.IsStartsWith("MainPlayerUnit"))
        {
           logWarning("OnHitByEnemy DestroyObject");
           fireEvent(10.0, [], "CheatOnHitByEnemy", []);

           GetSelf().GetStateControl().SetImmortalMode(false);
           addClassificatorObject( "MainPlayerUnit", GetMission().PlayerWasAttackMortar );

          //Autopilot
          if (GetMission().GetObject("MainPlayerUnit").GetSecondPilot().IsEnabledAutopilot())
          {
           //logWarning("[AutoPilot] Player end of route WayPointPlayerAttack.");
            GetMission().GetObject("MainPlayerUnit").GetSecondPilot().MoveTo_SetSpeed(30);
           //GetObject("MainPlayerUnit").GetSecondPilot().Land();
           GetMission().StartAutoPilot();
          }
          //Autopilot


            Component Wingman = GetMission().GetObject("MainPlayerUnit_Wingman_1");
            if (Wingman != null)
             if (!checkMask(Wingman, [GetMission().WingmanAttackMortarDone], []))
             {
                // для автопилола ... знаем что уже атаковали
                addClassificatorObject("MainPlayerUnit", GetMission().PlayerWasAttackMortar);

                 // отправить Wingman`a на XRay    и отставтиь там не двигаясь
                 //logWarning("MainPlayerUnit_Wingman_1 goto Xray. Add classificator WingmanAttackMortarDone='WINGMAN_ATTACK_DONE'");
                 GetUnitTask("MainPlayerUnit_Wingman_1").SetEnemyReactionType(ERT_FRIGID);
                 InvokeUnitTaskFunction("MainPlayerUnit_Wingman_1", "SetOrder_MoveTo", [GetNavPointBehPos("NavPoint_XRay"), 60.0]);
                 addClassificatorObject("MainPlayerUnit_Wingman_1", GetMission().WingmanAttackMortarDone);
                 // опрос расстояния между XRay Motar и MainPlayerUnit ... дабы отстегивать и пристегивать Wingman`a

                 //logWarning("Start GuideMode");
                 GetMission().m_WingmanGuide = new CC1M2WingmanGuide();
                 GetMission().m_WingmanGuide.Initialize(GetMission(), "CC1M2WingmanGuide");

                 sendEvent(0.0, SOID_MissionController, "StartDialog", ["DamagedMortar"]);
             }
        }
    }
}
//    миномёты и гаубицы


//    вьетнамские группы юнитов
class VietnameseGroupXRay1 extends CBaseC1M2Group
{
    String NavPointRetreat = "NavPoint_Retreat_GroupUnit_VietnameseSoldierGun_XRay_1";
}
class VietnameseGroupXRay2 extends CBaseC1M2Group
{
    String NavPointRetreat = "NavPoint_Retreat_GroupUnit_VietnameseSoldierGun_XRay_2";
}
class VietnameseGroupXRay3 extends CBaseC1M2Group
{
    String NavPointRetreat = "NavPoint_Retreat_GroupUnit_VietnameseSoldierGun_XRay_3";
}
class VietnameseGroupXRay4 extends CBaseC1M2Group
{
    String NavPointRetreat = "NavPoint_Retreat_GroupUnit_VietnameseSoldierGun_XRay_4";
}
class VietnameseGroupXRay5 extends CBaseC1M2Group
{
    String NavPointRetreat = "NavPoint_Retreat_GroupUnit_VietnameseSoldierGun_XRay_5";
}
class VietnameseGroupXRay6 extends CBaseC1M2Group
{
    String NavPointRetreat = "NavPoint_Retreat_GroupUnit_VietnameseSoldierGun_XRay_6";
}
class VietnameseGroupXRay7 extends CBaseC1M2Group
{
    String NavPointRetreat = "NavPoint_Retreat_GroupUnit_VietnameseSoldierGun_XRay_7";
}
class VietnameseGroupXRay8 extends CBaseC1M2Group
{
    String NavPointRetreat = "NavPoint_Retreat_GroupUnit_VietnameseSoldierGun_XRay_8";
}
class VietnameseGroupXRay9 extends CBaseC1M2Group
{
    String PointBrighten = "NavPoint_VietnamResurrect_9";     // ID объекта вокруг которого происходит рождение

    String NavPoint1 = "NavPoint_XRay_VietnamAttack_3";
    String NavPoint2 = "NavPoint_XRay_VietnamAttack_4";

    int maxCountAttackVietnamise = 3;
    int nowCountAttackVietnamise = 0;
     void Init()
     {
        SetEnemyReactionType(ERT_PASSIVE);
        CBaseC1M2Group::SavePosition();
     }
     void Init1()
        {
            //logWarning("VietnameseGroupXRay9::Init    " + getIdentificator(user));

            //ActivateMovement(false);
            CancelAllOrders();
            ActivateFire(true);
            ActivateRadar(true);

            for ( int i = 0; i < SoldierID.size(); i++)
                    sendEvent(0.0, SoldierID[i], "MoveToPointCreation", [SoldierID[i], SoldierPosition[i]]);

            sendEvent(20.0, getIdentificator(user), "AttackAmericanPoisition", []);
        }

    event void AttackAmericanPoisition()
    {
//        logWarning( "VietnameseGroupXRay9    nowCountAttackVietnamise=" + new String(nowCountAttackVietnamise));
        if (nowCountAttackVietnamise <= maxCountAttackVietnamise)
        {
            RefreshUnitsList();
            if ( m_Units.size() > 0)
            {
                String Unit = m_Units[randnum(m_Units.size())];
                Component SoldierAttack = GetUnitTask(Unit);
                Component Soldier = GetMission().GetObject(Unit);
//                logError(" Soldier ID=" +    Unit + "    SoldierAttack.MoveToFightPosition=" + new String(SoldierAttack.MoveToFightPosition) +
//                     " checkMask(Soldier, ['AttackAmericanPoisition'], [])=" + new String(checkMask(Soldier, ["AttackAmericanPoisition"], [])));
                if (SoldierAttack != null && !SoldierAttack.MoveToFightPosition && !( checkMask(Soldier, ["AttackAmericanPoisition"], [])))
                {
                     nowCountAttackVietnamise = nowCountAttackVietnamise + 1;
                    //logWarning(" Start Attack for soldier " + SoldierAttack.GetName());
                    //SoldierAttack.ActivateMovement(true);
                    InvokeUnitTaskFunction(SoldierAttack.GetName(),"SetQueueOrders",
                                 [[
                                     ["VietnamAttack", "SetOrder_MoveTo", [GetNavPointBehPos(NavPoint1), 0.0], "OnStopped"],
                                     ["VietnamAttack", "SetOrder_Guard", [NavPoint2, 20.0, 4], ""]
                                 ]]);
                     //SoldierAttack.AttackEnemy(EnemyId);
                    //logWarning(" Start Attack for soldier " + SoldierAttack.GetName());
                    addClassificatorObject(SoldierAttack.GetName(), "AttackAmericanPoisition");
                }
            }
            sendEvent( 1.0, getIdentificator(user), "AttackAmericanPoisition", []);
        }
        else
            sendEvent( 15.0, getIdentificator(user), "AttackAmericanPoisition", []);

    }

    event void OnUnitDestroyed(String _UnitID)
    {
        RefreshUnitsList();
        Component mortal = GetMission().GetObject(_UnitID);
        if ( checkMask(mortal, ["AttackAmericanPoisition"], []))
        {
            nowCountAttackVietnamise = nowCountAttackVietnamise - 1;
            removeClassificatorObject(_UnitID, "AttackAmericanPoisition");
        }

        //logWarning("VietnameseGroupXRay9 nowCountAttackVietnamise=" + new String(nowCountAttackVietnamise));
        CBaseUnitGroup::OnUnitDestroyed(_UnitID);
        CBaseC1M2Group::OnUnitDestroyed(_UnitID);
        //logWarning("VietnameseGroupXRay9 nowCountAttackVietnamise=" + new String(nowCountAttackVietnamise));
    }
}
class VietnameseGroupXRay10 extends CBaseC1M2Group
{
    String PointBrighten = "NavPoint_VietnamResurrect_10";     // ID объекта вокруг которого происходит рождение

    String NavPoint1 = "NavPoint_XRay_VietnamAttack_1";
    String NavPoint2 = "NavPoint_XRay_VietnamAttack_2";

    int maxCountAttackVietnamise = 3;
    int nowCountAttackVietnamise = 0;
     void Init()
     {
        CancelAllOrders();
        SetEnemyReactionType(ERT_PASSIVE);
        CBaseC1M2Group::SavePosition();
     }

     void Init1()
        {
            //logWarning("VietnameseGroupXRay10::Init     " + getIdentificator(user));

            //ActivateMovement(false);
            ActivateFire(true);
            ActivateRadar(true);

            for ( int i = 0; i < SoldierID.size(); i++)
                    sendEvent(0.0, SoldierID[i], "MoveToPointCreation", [SoldierID[i], SoldierPosition[i]]);

            sendEvent( 20.0, getIdentificator(user), "AttackAmericanPoisition", []);
         }

    event void AttackAmericanPoisition()
    {
        //logWarning( "VietnameseGroupXRay10    nowCountAttackVietnamise=" + new String(nowCountAttackVietnamise));
        if (nowCountAttackVietnamise <= maxCountAttackVietnamise)
        {
            RefreshUnitsList();
            if ( m_Units.size() > 0)
            {
                String Unit = m_Units[randnum(m_Units.size())];
                Component SoldierAttack = GetUnitTask(Unit);
                Component Soldier = GetMission().GetObject(Unit);

//                logError(" Soldier ID=" +    Unit + "    SoldierAttack.MoveToFightPosition=" + new String(SoldierAttack.MoveToFightPosition) +
//                     " checkMask(Soldier, ['AttackAmericanPoisition'], [])=" + new String(checkMask(Soldier, ["AttackAmericanPoisition"], [])));
                if (SoldierAttack != null && !SoldierAttack.MoveToFightPosition &&
                                !( checkMask(Soldier, ["AttackAmericanPoisition"], [])))
                {
                    nowCountAttackVietnamise = nowCountAttackVietnamise + 1;
                    //logWarning(" Start Attack for soldier " + SoldierAttack.GetName());
                    //SoldierAttack.ActivateMovement(true);
                    InvokeUnitTaskFunction(SoldierAttack.GetName(),"SetQueueOrders",
                                 [[
                                    ["VietnamAttack", "SetOrder_MoveTo", [GetNavPointBehPos(NavPoint1), 0.0], "OnStopped"],
                                    ["VietnamAttack", "SetOrder_Guard", [NavPoint2, 20.0, 4], ""]
                                 ]]);

                    //logWarning(" Start Attack for soldier " + SoldierAttack.GetName());
                    //SoldierAttack.AttackEnemy(EnemyId);
                    addClassificatorObject(SoldierAttack.GetName(), "AttackAmericanPoisition");
                }
            }
            sendEvent( 1.0, getIdentificator(user), "AttackAmericanPoisition", []);
        }
        else
            sendEvent( 20.0, getIdentificator(user), "AttackAmericanPoisition", []);
    }

    event void OnUnitDestroyed(String _UnitID)
    {
//        logError("VietnameseGroupXRay10 nowCountAttackVietnamise=" + new String(nowCountAttackVietnamise));
        RefreshUnitsList();
        Component mortal = GetMission().GetObject(_UnitID);
        if ( checkMask(mortal, ["AttackAmericanPoisition"], []))
        {
            nowCountAttackVietnamise = nowCountAttackVietnamise - 1;
            removeClassificatorObject(_UnitID, "AttackAmericanPoisition");
        }
        //logWarning("VietnameseGroupXRay10 nowCountAttackVietnamise=" + new String(nowCountAttackVietnamise));
        CBaseUnitGroup::OnUnitDestroyed(_UnitID);
        CBaseC1M2Group::OnUnitDestroyed(_UnitID);
        //logWarning("VietnameseGroupXRay10 nowCountAttackVietnamise=" + new String(nowCountAttackVietnamise));
    }
}

class VietnamTask9_10 extends CBaseAITask
{
    boolean MoveToFightPosition = false;
    float m_WalkSpeed             = 5.0;         // скорость с которой солдаты двигаютя от точки рождения до точки создани

    event void MoveToPointCreation(String _SoldierID, Matrix _Position)
    {
        ActivateMovement(true);
        Vector NewPos = _Position.origin;
        MoveToFightPosition = true;
        SetOrder_MoveTo(NewPos, m_WalkSpeed);
    }

        void OnStopped()
        {
            if (MoveToFightPosition)
            {
                //logWarning("[VietnamTask9_10::OnStopped] Unit=" + getIdentificator(user) + " MoveToFightPosition=" + new String(MoveToFightPosition));
                MoveToFightPosition = false;
                //ActivateMovement(false);
            }
            CBaseAITask::OnStopped();
        }

}

//    американские группы юнитов
class AmericanBase extends CBaseC1M2Group
{
    Vector min;    // мни. позиция солдат
    Vector max;    // макс. позиция солдат
    int m_DefectionUnit             = 0;     // количество в каждой группе юнитов делающий перебежку одновременно
    int m_MaxDefectionUnit        = 2;     //    max количество в каждой группе юнитов делающий перебежку одновременно

    float Xfactor = 0.0f;    //    множители для изменения эталонного квадрата
    float Yfactor = 0.0f;    //    умножение дла проекции эталонного квадрата на поверхность

    Array EthaIndices = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15/*, 16, 17, 18, 19, 20, 21, 22, 23*/]; // до Ethalon.size() - 1
    Vector Vcenter = new Vector(0.0f, 0.0f, 0.0f); // реального квадрата

    event void OnUnitDestroyed(String _UnitID)
    {
        CBaseUnitGroup::OnUnitDestroyed(_UnitID);
        RefreshUnitsList();

        //logWarning("[AmericanBase::OnUnitDestroyed] unitID=" + _UnitID + "    destroy!!");
        //logWarning("[AmericanBase::OnUnitDestroyed]    'GetDestroyedList().size()>m_Units.size()'" + new String(GetDestroyedList().size()>m_Units.size()));

        if ( GetDestroyedList().size()>m_Units.size() )
        {
            CurrentOrder = user.m_CurrentOrder;

            //logWarning("[AmericanBase::OnUnitDestroyed]    call    Brighten() groupID=" + getIdentificator(user));

            user.Brighten(SoldierPosBrighten);
        }
        Component mortal = GetMission().GetObject(_UnitID);
        if ( checkMask(mortal, ["Defection"], []))
        {
            //logWarning("    Group ID=" + getIdentificator(user) + " Unit ID=" + _UnitID + " destroy in Defection RecalculationDefection(-1)"+new String(RecalculationDefection(-1)));
            RecalculationDefection(-1);
            removeClassificatorObject(_UnitID, "Defection");
            //logWarning("[OnUnitDestroyed] GroupID=" + getIdentificator(user) + " release place ID=" + new String(mortal.CurrentIndex));
            GetStepIndex(mortal.CurrentIndex);
        }
    }

    boolean IsCanDefection()
    {
        //logWarning("[IsCanDefection] Group ID=" + getIdentificator(user) + " IsCanDefection()=" + new String( (m_DefectionUnit < m_MaxDefectionUnit) ));
        if (m_DefectionUnit < m_MaxDefectionUnit)
                return true;
        else
                return false;
    }

    void RecalculationDefection(int _count)
    {
        //logWarning("[RecalculationDefection]    Group ID=" + getIdentificator(user) + " m_DefectionUnit=" + new String( m_DefectionUnit + _count ));
        m_DefectionUnit = m_DefectionUnit + _count;
    }

    event void Displacment()
    {
                // вычисление векторов в пределах которых будут перемещаться юниты
        if (SoldierID[0].isEmpty())
        {
            logError("Array SoldierID is not initialized! Function    SavePosition was not started!");
        }

            Component Soldier = GetMission().GetObject(SoldierID[0]);
            if (Soldier != null)
            {
             min = getPosition(Soldier).origin;
             max = getPosition(Soldier).origin;
            }

            for( int i = 1; i < SoldierID.size(); i++)
             {

                Soldier = GetMission().GetObject(SoldierID[i]);
                 if (Soldier != null)
                 {
                    Vector tmp = getPosition(Soldier).origin;
//                    logWarning("tmp " + new String(tmp));

                    if (tmp.x < min.x)
                         min.x = tmp.x;

                    if (tmp.y < min.y)
                         min.y = tmp.y;

                    if (tmp.y > max.y)
                         max.y = tmp.y;

                    if (tmp.x > max.x)
                         max.x = tmp.x;

                    //logError(" SoldierID=" + getIdentificator(Soldier));
                 }
             }

             Vcenter = (max + min)/2.0;
             Xfactor = max.x - min.x;
             Yfactor = max.y - min.y;

         if (Xfactor < 10.0f)
                Xfactor = 10.0f;
         if (Yfactor < 10.0f)
                Yfactor = 10.0f;

                //logWarning("[Displacment] for Group " + getIdentificator(user));
                //logWarning("min " + new String(min));
                //logWarning("max " + new String(max));
                //logWarning(" Xfactor " + new String(Xfactor));
                //logWarning(" Yfactor " + new String(Yfactor));
                //logWarning("    Vcenter " + new String(Vcenter));

    }

    // вычисление координат для перебежки
    Vector GetStepPosition(int _Index)
    {
        Vector Result;
        Result.x = GetMission().Ethalon[_Index].x * Xfactor;
        Result.y = GetMission().Ethalon[_Index].y * Yfactor;
        Result.z = 0.0f;

        //logWarning("[GetStepPosition] Index=" + new String(_Index));
        //logWarning("[GetStepPosition] Ethalon=" + new String(GetMission().Ethalon[_Index]));
        //logWarning("[GetStepPosition] Result=" + new String(Result));
        return Vcenter + Result;
    }

    // удаление из массива доступных мест для перебежки
    Vector GetStepIndex(int _PrevIndex)
    {
        //logWarning("[GetStepIndex] _PrevIndex=" + new String(_PrevIndex));
        int Ind = randnum(EthaIndices.size());
        int Index = EthaIndices[Ind];
        EthaIndices.remove(Ind);
        if (_PrevIndex != -1)
            EthaIndices.add(_PrevIndex);

        //logWarning("[GetStepIndex] Index=" + new String(Index));
        return Index;
    }


    void Init()
    {
        //logWarning("CBaseC1M2Group::Init    " + getIdentificator(user));
        ActivateMovement(false);
        SetEnemyReactionType(ERT_PASSIVE);

        CBaseC1M2Group::SavePosition();
        InvokeGroupTaskFunction(getIdentificator(user), "Displacment", []);
    }

     void Init1()
        {
            //logWarning("[AmericanBase] Init for group with indentificator ID=" + getIdentificator(user) );

            ActivateMovement(false);

            for ( int i = 0; i < SoldierID.size(); i++)
                    sendEvent(0.0, SoldierID[i], "MoveToPointCreation", [SoldierID[i], SoldierPosition[i]]);
        }
}

class AmericanGroupXRay1 extends AmericanBase
{
    String PointBrighten = "NavPoint_AmericanResurrect_1";     // ID объекта вокруг которого происходит рождение
}

class AmericanGroupXRay2 extends AmericanBase
{
    String PointBrighten = "NavPoint_AmericanResurrect_1";     // ID объекта вокруг которого происходит рождение
}

class AmericanGroupXRay3 extends AmericanBase
{
    String PointBrighten = "NavPoint_AmericanResurrect_1";     // ID объекта вокруг которого происходит рождение
}

class AmericanGroupXRay4 extends AmericanBase
{
    String PointBrighten = "NavPoint_AmericanResurrect_2";     // ID объекта вокруг которого происходит рождение
}

class AmericanGroupXRay5 extends AmericanBase
{
    String PointBrighten = "NavPoint_AmericanResurrect_2";     // ID объекта вокруг которого происходит рождение
}

class AmericanGroupXRay6 extends AmericanBase
{
    String PointBrighten = "NavPoint_AmericanResurrect_2";     // ID объекта вокруг которого происходит рождение
}

// стоячие группы вьетнамезов на Xray
class VietnameseGroupXrayStay extends AmericanBase
{
    event void OnUnitDestroyed(String _UnitID)
    {
        CBaseUnitGroup::OnUnitDestroyed(_UnitID);
        RefreshUnitsList();

        //logWarning("[VietnameseGroupXrayStay::OnUnitDestroyed] unitID=" + _UnitID + "    destroy!!");
        //logWarning("[VietnameseGroupXrayStay::OnUnitDestroyed]    'GetDestroyedList().size()>m_Units.size()'" + new String(GetDestroyedList().size()>m_Units.size()));

        CurrentOrder = user.m_CurrentOrder;
        //logWarning("[VietnameseGroupXrayStay::OnUnitDestroyed]    call    Brighten() groupID=" + getIdentificator(user));

        user.Brighten(SoldierPosBrighten);

        Component mortal = GetMission().GetObject(_UnitID);
        GetUnitTask(_UnitID).Defection = false;
        if ( checkMask(mortal, ["Defection"], []))
        {
            //logWarning("[VietnameseGroupXrayStay::OnUnitDestroyed]    Group ID=" + getIdentificator(user) + " Unit ID=" + _UnitID + " destroy in Defection RecalculationDefection(-1)"+new String(RecalculationDefection(-1)));
            RecalculationDefection(-1);
            removeClassificatorObject(_UnitID, "Defection");
            //logWarning("[VietnameseGroupXrayStay::OnUnitDestroyed] GroupID=" + getIdentificator(user) + " release place ID=" + new String(mortal.CurrentIndex));
            GetStepIndex(mortal.CurrentIndex);
        }
    }
}
class VietnameseGroupStay1 extends VietnameseGroupXrayStay
{
    String PointBrighten = "NavPoint_VietnameseResurrect_1";
}
class VietnameseGroupStay2 extends VietnameseGroupXrayStay
{
    String PointBrighten = "NavPoint_VietnameseResurrect_2";
}
class VietnameseGroupStay3 extends VietnameseGroupXrayStay
{
    String PointBrighten = "NavPoint_VietnameseResurrect_3";
}
// стоячие группы вьетнамезов на Xray


//    группа америкаских юнитов кеоторые атакуют вьетнамцев там где motar
class AmericanGroupXRayAttack extends CBaseUnitGroup
{
    boolean MoveToMortar = false;
    boolean StopAndFight = false;

    event void AmericanAttack()
    {
        ActivateMovement(true);
        SetEnemyReactionType(ERT_PASSIVE);
        PopDelayedOrder();
        SetImmortalMode(true);
        MoveToMortar = true;
    }
     void OnPathEndReached()
     {
        if (MoveToMortar)
        {
            //logWarning("OnPathEndReached for    GroupUnit_AmericanAttack_XRay");
            SetFormation("CFrontFormation", 5, true, true);
            MoveToMortar = false;
            StopAndFight = true;
            sendEvent(3.0, getIdentificator(user), "StopAndFight", []);
        }
     }

     event void StopAndFight()
     {
         fireEvent(0.0, [], "AttackAmericanPoisition", []);
         InvokeGroupTaskFunction(getIdentificator(user), "ActivateMovement", [false]);
         Displacment();
     }

    Vector min;    // мни. позиция солдат
    Vector max;    // макс. позиция солдат
    int m_DefectionUnit             = 0;     // количество в каждой группе юнитов делающий перебежку одновременно
    int m_MaxDefectionUnit        = 3;     //    max количество в каждой группе юнитов делающий перебежку одновременно

    event void OnUnitDestroyed(String _UnitID)
    {
        CBaseUnitGroup::OnUnitDestroyed(_UnitID);
        RefreshUnitsList();

        Component mortal = GetMission().GetObject(_UnitID);
        if ( checkMask(mortal, ["Defection"], []))
        {
            //logWarning("    Group ID=" + getIdentificator(user) + " Unit ID=" + _UnitID + " destroy in Defection RecalculationDefection(-1)"+new String(RecalculationDefection(-1)));
            RecalculationDefection(-1);
            removeClassificatorObject(_UnitID, "Defection");
            GetStepIndex(mortal.CurrentIndex);
        }
    }

    boolean IsCanDefection()
    {
        //logWarning("[IsCanDefection] Group ID=" + getIdentificator(user) + " IsCanDefection()=" + new String( (m_DefectionUnit < m_MaxDefectionUnit) ));
        if (m_DefectionUnit < m_MaxDefectionUnit)
                return true;
        else
                return false;
    }

    void RecalculationDefection(int _count)
    {
        //logWarning("[RecalculationDefection]    Group ID=" + getIdentificator(user) + " m_DefectionUnit=" + new String( m_DefectionUnit + _count ));
        m_DefectionUnit = m_DefectionUnit + _count;
    }

    void Displacment()
    {
                // вычисление векторов в пределах которых будут перемещаться юниты
            Component Soldier = GetMission().GetObject(m_Units[0]);
            if (Soldier != null)
            {
             min = getPosition(Soldier).origin;
             max = getPosition(Soldier).origin;

                //logWarning("min " + new String(min));
                //logWarning("max " + new String(max));
            }

            for( int i = 1; i < m_Units.size(); i++)
             {
                    //logError("         m_Units[" + new String(i)+"]=" + new String(m_Units[i]));

                Soldier = GetMission().GetObject(m_Units[i]);
                 if (Soldier != null)
                 {
                    Vector tmp = getPosition(Soldier).origin;
//                    logWarning("tmp " + new String(tmp));

                    if (tmp.x < min.x)
                         min.x = tmp.x;

                    if (tmp.y < min.y)
                         min.y = tmp.y;

                    if (tmp.y > max.y)
                         max.y = tmp.y;

                    if (tmp.x > max.x)
                         max.x = tmp.x;
                 }
             }

             Vcenter = (max + min)/2.0;
             Xfactor = max.x - min.x;
             Yfactor = max.y - min.y;

         if (Xfactor < 10.0f)
                Xfactor = 10.0f;
         if (Yfactor < 10.0f)
                Yfactor = 10.0f;

                //logWarning("min " + new String(min));
                //logWarning("max " + new String(max));
                //logWarning(" Xfactor " + new String(Xfactor));
                //logWarning(" Yfactor " + new String(Yfactor));
                //logWarning("    Vcenter " + new String(Vcenter));
    }


    float Xfactor = 0.0f;    //    множители для изменения эталонного квадрата
    float Yfactor = 0.0f;    //    умножение дла проекции эталонного квадрата на поверхность

    Array EthaIndices = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15/*, 16, 17, 18, 19, 20, 21, 22, 23*/]; // до Ethalon.size() - 1
    Vector Vcenter = new Vector(0.0f, 0.0f, 0.0f); // реального квадрата

    // вычисление координат для перебежки
    Vector GetStepPosition(int _Index)
    {
//        logWarning("[GetStepPosition] _Index=" + new String(_Index));
        Vector Result;
        Result.x = GetMission().Ethalon[_Index].x * Xfactor;
        Result.y = GetMission().Ethalon[_Index].y * Yfactor;
        Result.z = 0.0f;
        //logError("[GetStepPosition] Vcenter" + new String(Vcenter));
        //logError("[GetStepPosition] Result=" + new String(Result));

        //logWarning(" Vcenter + Result=" + new String(Vcenter + Result));
        return Vcenter + Result;
    }

    // удаление из массива доступных мест для перебежки

    Vector GetStepIndex(int _PrevIndex)
    {
        //logWarning("[GetStepIndex] _PrevIndex=" + new String(_PrevIndex));
        //logWarning("[GetStepIndex] EthaIndices=" + new String(EthaIndices));
        int Ind = randnum(EthaIndices.size());
        int Index = EthaIndices[Ind];
        EthaIndices.remove(Ind);
        if (_PrevIndex != -1)
        {
            //logWarning("[GetStepIndex] _PrevIndex=" + new String(_PrevIndex) + " RELEASE!!!");
            EthaIndices.add(_PrevIndex);
        }
        //logWarning("[GetStepIndex] EthaIndices=" + new String(EthaIndices));
        return Index;
    }
}

class AmericanAttackerTask extends CBaseAITask
{
        boolean Defection                     = false;

        float m_Defection             = 4.0;        // скорость с которой солдаты двигаются во время стрельбы
        float m_RandomDefection = 0.5;         // вероятность с которой будут перебегать юниты

        int Timer = 0;

        int CurrentIndex = -1;             // изначальное положение вне квадрата

        void OnStopped()
        {
         if (Defection)
            {
                //logWarning("[AmericanAttackerTask::OnStopped]    Unit=" + getIdentificator(user) + " Defection=" + new String(Defection));

                Defection = false;
                ActivateMovement(false);

                m_Group.RecalculationDefection(-1);
                //logWarning(" Unit ID=" + getIdentificator(user) + "    call RecalculationDefection(-1)");
            }
            CBaseAITask::OnStopped();
        }

        void OnHitByEnemy(String _EnemyID)
        {
            if (m_Group.StopAndFight && !Defection)
            {
                if ( rand(0.0, 1.0) >= m_RandomDefection && m_Group.IsCanDefection())
                {
                 TimeDefection();
                 //logWarning(" Unit ID=" + getIdentificator(user) + " addClassificator 'Defection' ");
                 //logWarning("Group ID="+getIdentificator(m_Group)+" Defection Unit ID="+ getIdentificator(user)+" m_DefectionUnit=" + new String(m_Group.m_DefectionUnit));
                }
                else
                {
                        ChangeState();
                }
            }
            else
                    CBaseAITask::OnHitByEnemy(_EnemyID);
        }

        void ChangeState()
        {
             if( getGameTime() - Timer > 1000 )
             {
                    if (rand(0.0, 1.0) >= m_ChooseSitState)
                            sendEvent(0.0, getIdentificator(user), "OnSitStateChanged", [CHumanAttackStates::STATE_Sit]);
                    else
                            sendEvent(0.0, getIdentificator(user), "OnSitStateChanged", [CHumanAttackStates::STATE_Default]);
                    Timer = getGameTime();
             }
        }

        void TimeDefection()
        {
            addClassificator(user, "Defection");
            Defection = true;
            ActivateMovement(true);


            //logError(" Unit ID=" + getIdentificator(user) + "    call RecalculationDefection(1)");
            //Vector NewPos;
            //NewPos.x = rand(m_Group.min.x, m_Group.max.x);
            //NewPos.y = rand(m_Group.min.y, m_Group.max.y);

            CurrentIndex = m_Group.GetStepIndex(CurrentIndex);
            //logError("[TimeDefection] for Group ID=" + new String(m_Group.m_GroupID) + "CurrentIndex=" + new String(CurrentIndex));
            //logError("[TimeDefection] m_Group.GetStepPosition(CurrentIndex)=" + new String(m_Group.GetStepPosition(CurrentIndex)));
            SetOrder_MoveTo( m_Group.GetStepPosition(CurrentIndex), m_Defection);

/*
            if (CheckDefection(NewPos))
            {
                SetOrder_MoveTo( NewPos, m_Defection);
                //logWarning("[TimeDefection] UnitID=" + getIdentificator(user) + " Move to point=" + new String(NewPos));
                m_Group.RecalculationDefection(1);
            }
            else
            {
                ChangeState();
            }
 */
        }

    void OnMoveFailed()        // TMP
    {
        //logError("[OnMoveFailed] UnitID=" + getIdentificator(user) );
        //logError("Please send file 'editor.html' to Ironweed");
    }

    Vector LastPosition = new Vector(0, 0, 0);
    boolean CheckDefection(Vector _Pos)
    {
        if (LastPosition.Magnitude() != 0)
        {
            float module = ( LastPosiotion - _Pos).Magnitude();
            //logWarning(" Module=" + new String(module)+ "     (module<5) =" + new String(module<5));
            if (module<5)
                return false;
        }
        LastPosition = _Pos;
        return true;
    }

}
//    группа америкаских юнитов кеоторые атакуют вьетнамцев там где motar




// Группа для патрульных
class AmericanPatrolTOC extends AmericanBase
{
    void Init()
    {
    }
}
// Task для патрульных ... несинхронизированный патруль
class C1M2PatrolMoving extends CBaseAITask
{
    void InitPatrolPointIndex (int _TotalPatrolPoints)
    {
        //logWarning( "[InitPatrolPointIndex] " + GetIdentificator() + " have RANK " + new String (GetRank()) );
        if ( GetRank()==0)
     {
            m_TotalPatrolPoints = 1;
            m_NextPatrolPoint = 0;
     }
     else
     {
         m_TotalPatrolPoints = 1 ;
         m_NextPatrolPoint = 2;
        }
        //logWarning( "[InitPatrolPointIndex] " + GetIdentificator() + " goes to nav-point " + new String (m_NextPatrolPoint) );
    }

 int GetNextPatrolPoint()
 {
     int Ret;
     Ret = m_NextPatrolPoint;

     if (GetRank()==0 && m_NextPatrolPoint == 2)
     {
        Ret = 0;
        m_NextPatrolPoint = 0;
     }

     if (GetRank()==1 && m_NextPatrolPoint == 4)
     {
        Ret = 2;
        m_NextPatrolPoint = 2;
     }

     m_NextPatrolPoint++;

        //logWarning( "[GetNextPatrolPoint] " + GetIdentificator() + " have RANK " + new String (GetRank()) );
        //logWarning( "[GetNextPatrolPoint] " + GetIdentificator() + " next patrol point " + new String (m_NextPatrolPoint) );
        //logWarning( "[GetNextPatrolPoint] " + GetIdentificator() + " goes to nav-point " + new String (Ret) );

     return Ret;
    }
}

// Группа для охранников
class AmericanGuardTOC extends AmericanBase
{
     void Init()
        {
            ActivateMovement(false);
        }
}

// BaseGroup`s for C1M2
// Base Group Bombard
class GroupBombard    extends CBaseUnitGroup
{
    Array m_TargetNavPoint1 = [];
    Array m_TargetNavPoint2 = [];
    Array m_TargetNavPoint3 = [];
    Array m_TargetNavPoint4 = [];

    int m_CounterFirePlace = 1;

    void Init()
    {
//     Стрелять по низкой траектории    setHighTrajectory(false);
         for ( int i = 0; i < m_Units.size(); i++)
         {
             Component Behavior = GetUnitBehavior(m_Units[i]);
             if ( Behavior != null)
             {
                 Behavior.setHighTrajectory(false);
             }
         }
    }

    event void FirePoint()
    {
        //logWarning("[FirePoint] for group with ID="+ getIdentificator(user) );
        if (m_CounterFirePlace == 4)
                m_CounterFirePlace = 1;

        if (m_CounterFirePlace == 1)
                Array ArrayID = m_TargetNavPoint1;
        else if (m_CounterFirePlace == 2)
                Array ArrayID = m_TargetNavPoint2;
        else if (m_CounterFirePlace == 3)
                Array ArrayID = m_TargetNavPoint3;

        //logWarning("[FirePoint] ArrayID=" + new String(ArrayID));
        //logWarning("[FirePoint] m_CounterFirePlace=" + new String(m_CounterFirePlace));
        Array m_Units = GetUnitsList();
        for ( int i = 0; i < m_Units.size(); i++)
            InvokeUnitTaskFunction(m_Units[i],"SetFireStyle_SpecialFire",[ArrayID[i] ]);


        sendEvent( 40.0, getIdentificator(user), "FirePoint", []);
        m_CounterFirePlace = m_CounterFirePlace + 1;
    }

    event void Shoot( boolean _fire)
    {
        if (m_TargetNavPoint1.size() == 0)
        {
            logError("Group:"+ getIdentificator(user) + " dim m_TargetNavPoint1.size()= 0");
            return;
        }

        if (m_Units.size() == 0)
        {
            logError("Group:"+ getIdentificator(user) +" dim m_Units.size() = 0");
            return;
        }

        //logWarning("[Shoot]Srart Fire group '" + getIdentificator(user) + " - " + new String(_fire));

        Array m_Units = GetUnitsList();

        for ( int i = 0; i < m_Units.size(); i++)
        {
            if (_fire)
                sendEvent(randnum(5), getIdentificator(user), "ShootBigGun", [m_Units[i], m_TargetNavPoint1[i]]);
//                InvokeUnitTaskFunction(m_Units[i],"SetFireStyle_SpecialFire",[m_TargetNavPoint1[i] ]);
            else
                    SetOrder_NoFire();
        }
    }

        event void ShootRand (boolean _fire, Array _TargetList)
        {
            if (_TargetList.size() == 0)
            {
             logError("Group:"+ getIdentificator(user) + " dim _TargetList.size()= 0");
             return;
            }

            if (m_Units.size() == 0)
            {
             logError("Group:"+ getIdentificator(user) +" dim m_Units.size() = 0");
             return;
            }

             //logWarning("[ShootRand]Srart Fire group '" + getIdentificator(user) + " - " + new String(_fire));

            Array m_Units = GetUnitsList();
            for ( int i = 0; i < m_Units.size(); i++)
            {
             if (_fire)
                 sendEvent(randnum(5), getIdentificator(user), "ShootBigGun", [m_Units[i], _TargetList[randnum(_TargetList.size())]]);
//                 InvokeUnitTaskFunction(m_Units[i],"SetFireStyle_SpecialFire",[_TargetList[randnum(_TargetList.size())] ]);
             else
                     SetOrder_NoFire();
            }
        }

        event void ShootBigGun(String _UnitID, String _Purpose)
        {
         InvokeUnitTaskFunction(_UnitID,"SetFireStyle_SpecialFire",[_Purpose]);
        }

/*
     event void FireSoldier( boolean _fire , Array _TargetList)
     {
     }
 */
}

// Base Soldier Group
class CBaseC1M2Group extends CBaseUnitGroup
{
    // endless fighting
    Array SoldierPosition = [];             // массив матриц позиций рождения юнитов
    Array SoldierID             = [];             // массив ID солдат группы
    Array SoldierPosBrighten = [];        // массив вектров позиций рождений юнитов

    Vector PosBright;                        // вектор относительно которого
    float radius = 20.0;                 // с радиусом radius будут восстанавливаться(рождаться) солдаты
    String PointBrighten = "";     // ID объекта вокруг которого происходит рождение

    boolean Run_Away = false;        // убегают ли юниты    от врага


    Component CurrentOrder;

    void Init()
    {
        //logWarning("CBaseC1M2Group::Init    " + getIdentificator(user));

        SetEnemyReactionType(ERT_PASSIVE);
        SetFormation("CFrontFormation", 5, true, true);

        CBaseC1M2Group::SavePosition();

        InvokeGroupTaskFunction(getIdentificator(user), "Displacment", []);
    }

    void Init1()
    {
    }

    // создание массива новых матриц рождени
    Array CreatePositionBrighten()
    {
        Array _NewPos;

         //logWarning("[CBaseC1M2Group::CreatePositionBrighten()]     for    " + getIdentificator(user));

        if (PointBrighten == "")
         {
             logWarning("Group with ID=" + getIdentificator(user) + " don`t have PointBrighten, soldiers are born in point of the creation!");
             return SoldierPosition;
         }

        Component NavPointBright = new #GameController().GetObject(PointBrighten);
        if (NavPointBright == null)
         {
             logError("Component PointBrighten --- null!!!!");
             return SoldierPosition;
         }

        PosBright = getPosition(NavPointBright).origin;

        _NewPos = clone(SoldierPosition);
        for (int i = 0; i < SoldierID.size(); i++)
             _NewPos[i].origin = PosBright + new Vector(rand(radius), rand(radius), 0.0);

        return _NewPos;
    }

    // Save Position group unit
    event void SavePosition()
    {
        //logWarning("[SavePosition]    for group " + getIdentificator(user));

        user.RefreshUnitsList();
        Array _Units = user.m_Units;
        if (0 == _Units.size())
                return;

        for ( int i = 0; i < _Units.size(); i++)
        {

            Component Soldier = new #GameController().GetObject(_Units[i]);
            if (null == Soldier)
                    return;

            Matrix _Pos = getPosition(Soldier);
            SoldierPosition.add(_Pos);
            SoldierID.add(_Units[i]);
        }
        SoldierPosBrighten = CreatePositionBrighten();
    }

    // Brighten on all unit destroy
    void Brighten( Array _SoldierPosition )
    {
        CurrentOrder = user.m_CurrentOrder;

        //logWarning("[Brighten] for " + getIdentificator(user));
        //logWarning("[Brighten] CurrentOrder " + new String(CurrentOrder) + "    Order " + new String(CurrentOrder.m_Order));

         if (getIdentificator(user).IsEndsWith("DesantGroup"))
         {
            //logError("SoldierID=" +  new String(SoldierID));
            //logError("_SoldierPosition" + new String(_SoldierPosition));

            //logError("  SoldierPosition=" + new String(SoldierPosition));
            //logError("  SoldierID=" + new String(SoldierID));
            //logError("  SoldierPosBrighten=" + new String(SoldierPosBrighten));
         }

         for ( int i = 0; i < SoldierID.size(); i++)
         {
             Component Unit = new #GameController().GetObject(SoldierID[i]);
             if (Unit != null && !checkMask(Unit, [], [CLASSIFICATOR_DEAD_OBJECT]))
             {
                 Component Soldier = new #GameController().GetObject(SoldierID[i]);
                 Component Behavior = GetUnitBehavior(SoldierID[i]);
                 if ( Behavior != null)
                 {
//                  if (getIdentificator(user).IsEndsWith("DesantGroup"))
//                  {
//                    logError("  i=" + new String(i));
//                    logWarning("[Brighten] ID="+ new String(SoldierID[i]) + " GroupID=" + getIdentificator(user) + " _SoldierPosition[i]" + new String(_SoldierPosition[i]));
//                  }

                   Behavior.SetPosition(_SoldierPosition[i]);
                 }
             }
         }

        user.RestoreGroup();
        user.RefreshUnitsList();
        Init1();
        sendEvent(2.0, getIdentificator(user), "GroupPopDelayedOrder", []);
    }

    event void StartGuardGroup( String _TargetPoint)
    {
        //logWarning("Group with ID=" + getIdentificator(user) + " start guard with Target=" + _TargetPoint);

        SetOrder_Guard(_TargetPoint,50,0);
    }

    void OnEnemyTargeted(Component _UnitAlerted)
    {
        String TargetedUnit = _UnitAlerted.GetTargetedEnemy();

        //logWarning("Unit: with ID="+ _UnitAlerted.GetName() + " see enemy with ID=" +_UnitAlerted.GetTargetedEnemy()+" Start Attack!!!");

        SetOrder_Attack([TargetedUnit], ERT_AGGRESSIVE);
    }

    event void GroupPopDelayedOrder()
    {
        //logWarning("[CBaseC1M2Group::GroupPopDelayedOrder()]    for    " + getIdentificator(user) + " isDelayedOrder()="+ new String(isDelayedOrder()));

        if (isDelayedOrder())
        {
            SetEnemyReactionType(ERT_PASSIVE);
            PopDelayedOrder();
        }
//        else
//           logError("Group with ID=" + getIdentificator(user) + " do not have PopDelayedOrder!!!");
    }

    event void OnUnitDestroyed(String _UnitID)
    {
        CBaseUnitGroup::OnUnitDestroyed(_UnitID);
        RefreshUnitsList();

         //logWarning("[CBaseC1M2Group::OnUnitDestroyed] unitID=" + _UnitID + "    destroy!!");
         //logWarning("[CBaseC1M2Group::OnUnitDestroyed] GroupID="    + getIdentificator(user) + "    destroy!!");
         //logWarning("[CBaseC1M2Group::OnUnitDestroyed]    checkMask=" + new String(checkMask(user, [CLASSIFICATOR_DEAD_OBJECT], [])));

         if (!checkMask(user, ["RunAway"], []))
                InvokeUnitTaskFunction(_UnitID, "ActivateMovement", [true]);

         if (!checkMask(user, [CLASSIFICATOR_DEAD_OBJECT], []))
            {
                if (!Run_Away && GetDestroyedList().size() > 3)
                {
                    // если вся группа не мертва и количество живых меньше 4 то мы убегаем
                    RefreshUnitsList();
                    //logWarning("[RunAway] Group ID=" + getIdentificator(user) + " amount unit`s " + new String(m_Units.size()));
                    for ( int i = 0; i < m_Units.size(); i++)
                    {
                     //logWarning("[RunAway] Unit`s ID=" + new String(m_Units[i]) + " RunAway!!!!");
                     addClassificatorObject(_UnitID, "RunAway");
                     sendEvent(randnum(5.0) , m_Units[i], "RunAway", []);
                    }
                    Run_Away = true;
                }
            }
         else
         {
             Run_Away = false;
             CurrentOrder = user.m_CurrentOrder;
             Brighten(SoldierPosBrighten);
         }
    }

    // fireEvent(0.0, [], "Test", []);
    boolean isDelayedOrder()
    {
        Component Content = GetMission().GetContent();
        if (null == Content)
            return;

        Array ObjRec = Content.FindObjectRecord(getIdentificator(this));
        if (ObjRec.isEmpty())
            return;

        Component PropertiesMap = new CPropertiesMap(ObjRec[CMissionContent::INDEX_Properties]);
        return PropertiesMap.Get("DelayedOrder", false);

/*        Array PropertyNameList = PropertiesMap.GetPropertyNamesList();
        for (int i = 1; i < PropertyNameList.size(); i++)
        {
             if (PropertyNameList[i] == "DelayedOrder")
                    return PropertiesMap.Get("DelayedOrder", false);
             {
                variant Prop = PropertiesMap.Get("DelayedOrder", false);
                logError(new String(Prop));
                if (Prop == true)
                        logError("Properties 'DelayedOrder' ==" + new String(Prop) + "    Group with ID="+ getIdentificator(this));
             }
        }
        return false; */
    }
}

class C1M2VietnameseTask extends CBaseAITask
{
    event void RunAway()
    {
        //logWarning("[RunAway] for unit " + getIdentificator(user));

        if (m_Group.Run_Away && !checkMask(user, [CLASSIFICATOR_DEAD_OBJECT], []))
        {
            ActivateMovement(true);
            m_EnemyReactionType = ERT_FRIGID;
            if( !m_Group.NavPointRetreat.isEmpty())
            {
                SetOrder_MoveTo( GetNavPointBehPos(m_Group.NavPointRetreat), 7.0);
                sendEvent(randnum(10.0) , getIdentificator(user), "StopRunAway", []);
            }
            else
                    logError("NavPointRetreat is empty! Group - " + new String(getIdentificator(m_Group)));
        }
    }

    event void StopRunAway()
    {
        //logWarning("[StopRunAway] for unit " + getIdentificator(user));
        if (m_Group.Run_Away && !checkMask(user, [CLASSIFICATOR_DEAD_OBJECT], []))
        {
            m_EnemyReactionType = ERT_PASSIVE;
            ActivateMovement(false);
            CBaseAITask::OnEnemyTargeted();
            sendEvent(randnum(5.0) , getIdentificator(user), "RunAway", []);
        }
    }
}

// Taks для солдат (перебегают раз в 120000 мсек.)
 class C1M2BaseAmericanTask extends CBaseAITask
    {
        Vector Pos;    //    начальная позици
        float radius = 20.0;    // макс. радиус перебежек
        int m_TimeTerroristRun = 120000;    //    время инициирования новой перебежки

        void Init()
        {
            Pos = getPosition((new #GameController()).GetObject(getIdentificator(user))).origin;
        }

        event void StartRunCircle()
        {
            PostDelayedEvent( "TimeRun",[], m_TimeTerroristRun);
        }

        void TimeRun()
        {
             Vector NewPos = Pos + new Vector( rand(radius), rand(radius), 0.0);
             SetOrder_MoveTo( NewPos, 0.0);
             PostDelayedEvent( "TimeRun",[], m_TimeTerroristRun);
        }
    }


    // Task для америкосов .. с переходом от места рождения к месту битвы
    class C1M2XrayAmericanTask extends C1M2BaseAmericanTask
    {
        boolean MoveToFightPosition = false;
        boolean Defection                     = false;

        float m_WalkSpeed             = 5.0;         // скорость с которой солдаты двигаютя от точки рождения до точки создани
        float m_Defection             = 4.0;        // скорость с которой солдаты двигаются во время стрельбы
        float m_RandomDefection = 0.5;         // вероятность с которой будут перебегать юниты

        int Timer = 0;

        //    float     m_ChooseSitState        = 0.5; BaseAITask.script

        //  FOR ONLY VIETNAMESE GROUP STAY ON XRAY
        void DoNotMoveToFightPosition()
        {
          MoveToFightPosition = true;
        }
        //  FOR ONLY VIETNAMESE GROUP STAY ON XRAY

        event void MoveToPointCreation(String _SoldierID, Matrix _Position)
        {
            ActivateMovement(true);
            Vector NewPos = _Position.origin;
            MoveToFightPosition = true;
            SetOrder_MoveTo(NewPos, m_WalkSpeed);
        }


        void OnEnemyTargeted()
        {
            CBaseAITask::OnEnemyTargeted();
/*
             if (!MoveToFightPosition && !Defection)
                    CBaseAITask::OnEnemyTargeted();
            else
            {
//                 logWarning("[C1M2XrayAmericanTask::OnEnemyTargeted()]    Unit ID=" + getIdentificator(user)+ " see ENEMY ID=" + GetTargetedEnemy());
            }
 */
        }

        void OnStopped()
        {
            if (MoveToFightPosition)
            {
                //logWarning("[C1M2XrayAmericanTask::OnStopped] Unit=" + getIdentificator(user) + " MoveToFightPosition=" + new String(MoveToFightPosition));
                MoveToFightPosition = false;
                ActivateMovement(false);
            }
            else if (Defection)
            {
                //logWarning("[C1M2XrayAmericanTask::OnStopped]    Unit=" + getIdentificator(user) + " Defection=" + new String(Defection));

                Defection = false;
                ActivateMovement(false);

                m_Group.RecalculationDefection(-1);
                //logWarning(" Unit ID=" + getIdentificator(user) + "    call RecalculationDefection(-1)");
            }

            CBaseAITask::OnStopped();
        }

        void OnHitByEnemy(String _EnemyID)
        {
           //if (getIdentificator(user).HasSubstring("Stay"))
           //   logError("[OnHitByEnemy] Unit=" + getIdentificator(user) + "  MoveToFightPosition=" + new String(MoveToFightPosition) + "   Defection="+ new String(Defection));

           if (getIdentificator(user).IsStartsWith("Desant"))
              if (!m_Group.DesantStartFight)
                 return;

            if (!MoveToFightPosition && !Defection)
            {
                if ( rand(0.0, 1.0) >= m_RandomDefection && m_Group.IsCanDefection())
                {
                 TimeDefection();
                 //logWarning(" Unit ID=" + getIdentificator(user) + " addClassificator 'Defection' ");
                 //logWarning("Group ID="+getIdentificator(m_Group)+" Defection Unit ID="+ getIdentificator(user)+" m_DefectionUnit=" + new String(m_Group.m_DefectionUnit));
                }
                else
                {
                        ChangeState();
                }
            }
            else
                    CBaseAITask::OnHitByEnemy(_EnemyID);
        }

        void ChangeState()
        {
             if( getGameTime() - Timer > 1000 )
             {
                 if (rand(0.0, 1.0) >= m_ChooseSitState)
                        sendEvent(0.0, getIdentificator(user), "OnSitStateChanged", [CHumanAttackStates::STATE_Sit]);
                 else
                        sendEvent(0.0, getIdentificator(user), "OnSitStateChanged", [CHumanAttackStates::STATE_Default]);
                Timer = getGameTime();
             }
        }

        int CurrentIndex = -1;             // изначальное положение вне квадрата

        // fireEvent(0.0, [], "Displacment", []);
        // fireEvent(0.0, [], "TimeDefection", []);

        event void TimeDefection()
        {
            addClassificator(user, "Defection");
            Defection = true;
            ActivateMovement(true);

            //logWarning(" Unit ID=" + getIdentificator(user) + "    call RecalculationDefection(1)");

            CurrentIndex = m_Group.GetStepIndex(CurrentIndex);
            //logError("[TimeDefection] for Group ID=" + new String(m_Group.m_GroupID) + " CurrentIndex=" + new String(CurrentIndex));
            //logError("[TimeDefection] for Ubnit ID=" + new String(getIdentificator(user)));
            //logError("[TimeDefection] m_Group.GetStepPosition(CurrentIndex)=" + new String(m_Group.GetStepPosition(CurrentIndex)));
            SetOrder_MoveTo( m_Group.GetStepPosition(CurrentIndex), m_Defection);
        }

      void OnMoveFailed()        // TMP
      {
        //logError("[OnMoveFailed] UnitID=" + getIdentificator(user) );
        //logError("Please send file 'editor.html' to Ironweed");
      }
    }

/*
    class C1M2American1 extends C1M2RunCircleAmericanTask
     {
     }
    class C1M2American2 extends C1M2RunCircleAmericanTask
     {
     }
    class C1M2American3 extends C1M2RunCircleAmericanTask
     {
     }
    class C1M2American4 extends C1M2RunCircleAmericanTask
     {
     }
    class C1M2American5 extends C1M2RunCircleAmericanTask
     {
     }
    class C1M2American6 extends C1M2RunCircleAmericanTask
     {
     }
 */

 class WingmanGroup extends CBaseUnitGroup
 {

    int countTakeOfHelic;

    Component HelicCurrentOrder = new CGroupOrder();;

    void Init()
    {
        SetImmortalMode(true);
        SetEnemyReactionType(ERT_PASSIVE);
        countTakeOfHelic = 0;
    }

    event void FlyTransport()
    {
        //logError("[FlyTransport] GetMission().m_PlayerFly=" + new String(GetMission().m_PlayerFly));
        sendEvent( 0.0, getIdentificator(user), "StartPatrol", []);

        GetMission().SendPersonalCockpitMessage("MainPlayerUnit", CC1M2Mission_Strings::str_C1M2_Breadshow_StartMove_02, CCockpitColorMap::m_NeutralNewsColor, "str_C1M2_Breadshow_StartMove_02");

        if (!GetMission().m_PlayerFly)
        {
            sendEvent(10.0, SOID_MissionController, "StartDialog", ["PlayerDoNotFly"]);
        }
    }
    event void Formation()
    {
      SetFormation("CWedgeFormation", 50, true, false);
    }

    event void StartPatrol()
    {
        //PopDelayedOrder();
      for ( int i = 0; i < m_Units.size(); i++)
      {
        sendEvent(2*i, m_Units[i], "Vzlet", []);
           //InvokeUnitTaskFunction( m_Units[i],"Vzlet",[]);
      }

        sendEvent( 30.0, getIdentificator(user), "PopDelayedOrder", []);
        sendEvent( 30.0, SOID_MissionController, "CorrectionAutoPilot", []);
        sendEvent( 40.0, getIdentificator(user), "Formation", []);
    }

    void SaveCurrentOrder()
    {
        //logError("SaveCurrentOrder");
        //logWarning("[SaveCurrentOrder] CurrentOrder " + new String(user.m_CurrentOrder) + "    Order " + new String(user.m_CurrentOrder.m_Order));
        //logWarning("[SaveCurrentOrder] m_NextPatrolPoint=" + new String(user.m_CurrentOrder.m_NextPatrolPoint));
        //logWarning("[SaveCurrentOrder] m_PatrolPath=" + new String(user.m_CurrentOrder.m_PatrolPath.size()));

        HelicCurrentOrder = new CGroupOrder(user.m_CurrentOrder);
        //logWarning("[SaveCurrentOrder] HelicCurrentOrder " + new String(HelicCurrentOrder) + "    Order " + new String(HelicCurrentOrder.m_Order));
    }

    void LoadCurrentOrder(Component _Order)
    {
        //logError("BEFORE");
        //logWarning("[LoadCurrentOrder] HelicCurrentOrder " + new String(HelicCurrentOrder) + "    Order " + new String(HelicCurrentOrder.m_Order));
        //logWarning("  [LoadCurrentOrder]  CurrentOrder " + new String(HelicCurrentOrder) + "    Order " + new String(HelicCurrentOrder.m_Order));
        //logWarning("  [LoadCurrentOrder]  m_NextPatrolPoint=" + new String(HelicCurrentOrder.m_NextPatrolPoint));
        //logWarning("  [LoadCurrentOrder]  m_PatrolPath=" + new String(HelicCurrentOrder.m_PatrolPath.size()));
        user.m_CurrentOrder = new CGroupOrder(HelicCurrentOrder);
        //logError("AFTER");
        //logWarning("[LoadCurrentOrder] CurrentOrder " + new String(user.m_CurrentOrder) + "    Order " + new String(user.m_CurrentOrder.m_Order));
        //logWarning("[LoadCurrentOrder] m_NextPatrolPoint=" + new String(user.m_CurrentOrder.m_NextPatrolPoint));
        //logWarning("[LoadCurrentOrder] m_PatrolPath=" + new String(user.m_CurrentOrder.m_PatrolPath.size()));
        RepeatOrder();
    }


    event void CountUnloadHelicopter( String _HelicID)
    {
        countTakeOfHelic = countTakeOfHelic + 1;
        logWarning("Helic ID=" + _HelicID + " Unload Count="+ new String(countTakeOfHelic));
        if (countTakeOfHelic == m_Units.size())
           sendEvent(10.0, "C1M2WingmanGroup", "WingmanContinuePatrol",  []);
    }

    event void WingmanContinuePatrol()
    {
      ForEachUnitTask("StartTransport", []);
      logWarning("WingmanContinuePatrol");

//        if (countTakeOfHelic == m_Units.size())
//        {
            removeClassificatorObject("WingmanGroup", GetMission().WingmanGroupLand);     // для PositionWatcher
            HelicCurrentOrder.m_MovingSpeed = 50.0;
            ForEachUnitTask("SetFlyingHeight", [200.0]);
            LoadCurrentOrder(HelicCurrentOrder);
            countTakeOfHelic = 0;
//        }
    }

     event void OnGroupLoaded( String _GroupID)
     {
         //logWarning("Group ID="+ getIdentificator(user) + " OnGroupLoaded");
         //logWarning("countTakeOfHelic=" + new String(countTakeOfHelic));
         countTakeOfHelic = countTakeOfHelic + 1;
         sendEvent( 0.0, _GroupID.GetPartPreceding("_DesantGroup"), "StartTransport",    [] );
         if (countTakeOfHelic == m_Units.size())
         {

             fireEvent( 5.0, [], "FlyTransport", []);
             countTakeOfHelic = 0;
             GetMission().StartWingman = true;
         }
     }

     void OnPathEndReached()
     {
         //logWarning("OnPathEndReached for    WingmanGroup");
         SetOrder_Recharge("NavPoint_Plei_Me_Base");
     }

     event void OnUnitFormationReached1(String _LeaderID)
     {
      logWarning("[OnUnitFormationReached] Unit with ID=" +_LeaderID + "    ");
      GetMission().m_Watcher1.OnUnitFormationReached(_LeaderID);
     }
     void OnUnitFormationReached(String _LeaderID)
     {
       sendEvent(0.0, getIdentificator(user), "OnUnitFormationReached1", [_LeaderID]);
     }
 }




 class WingmanGroup1 extends CBaseUnitGroup
 {
  // sendEvent(0.0, "WingmanGroup1", "TransportLastFly", []);
   event void TransportLastFly()
   {
    logWarning("WingmanGroup1::TransportLastFly");
    RefreshUnitsList();
    ForEachUnitTask("StartTransport", []);
    SetFormation("CWedgeFormation", 50, true, false);
    PopDelayedOrder();
   }
 }
 class WingmanGroup2 extends CBaseUnitGroup
 {
 }

 class CTransportTask extends CTransportWingmanTask
 {
    void Init()
    {
      GetSelf().SetImmortalMode(true);
    }
    boolean TransportMoveToLand = false;

    event void StartTransport()
    {
      sendEvent(randnum(15), getIdentificator(user), "Wingman_TakeOff",    [] );
    }

    event void Vzlet()
    {
      Component Helic = GetSelf();
      Matrix Position = getPosition(Helic);
      Vector Dir = Position.xvec;
      Dir.Normalize();
      Vector PreloadedPosition = Position.origin - 600.0 * Dir;
      PreloadedPosition.z = PreloadedPosition.z + rand(30.0, 200.0);
      float _speed = 5.0 - 0.5*GetRank();
      SetOrder_MoveTo(PreloadedPosition, _speed);
    }

    event void MoveToPointLand(float _Height, float _Speed)
    {
        logWarning("[MoveToPointLand] event MoveToPointLand    HelicID=" + getIdentificator(user));
        logWarning("[MoveToPointLand] _Height=" + new String(_Height) + "  _Speed=" + new String(_Speed));
        TransportMoveToLand = true;
        SetFlyingHeight(_Height);
        SetOrder_MoveTo( GetNavPointBehPos("NavPoint_Landing_" + getIdentificator(user)), _Speed);
        //logError("SetOrder_MoveTo NAVPOINT="+ "NavPoint_Landing_" + getIdentificator(user));
    }

     void OnStopped()
     {
         CTransportWingmanTask::OnStopped();
        //logWarning("[OnStopped] MoveToPointLand=" + new String(MoveToPointLand));
         if ( TransportMoveToLand )
         {
            // диалог про посадке (точка посадки достигнута первым вертолетом)
            if (getIdentificator(user) == "Plei_Me_Uh1d_1")
                    sendEvent(0.0, SOID_MissionController, "StartDialog", ["ExchangePointLand"]);
            // диалог про посадку

             sendEvent(0.0, getIdentificator(user), "Landing", ["NavPoint_Landing_" + getIdentificator(user)]);
             sendEvent(10.0, getIdentificator(user) + "_DesantGroup", "UnloadHelicopter", [getIdentificator(user), "NavPoint_Landing_See_" + getIdentificator(user)]);
         }
     }

     event void WingmanMidair()
     {
         //logWarning("WingmanMidair");
         TransportMoveToLand = false;
     }
 }

 class DesantGroup extends AmericanBase
 {
     String    sA;
     String    sB;
     String    sC;

     Vector    vA;
     Vector    vB;
     Vector    vC;

     boolean DesantStartFight = false;

     String PointBrighten = "NavPoint_AmericanResurrect_1";     // ID объекта вокруг которого происходит рождение
     String PersonalHelicID;
     String PersonalNavPointLoad;

     String NavPointTeleport; // специально для DesantGroup

    Array SoldierPosition = [];             // массив матриц позиций рождения юнитов
    Array SoldierID             = [];             // массив ID солдат группы
    Array SoldierPosBrighten = [];        // массив вектров позиций рождений юнитов

    // Save Position group unit
    event void SavePosition()
    {
        logWarning("[SavePosition]    for group " + getIdentificator(user));

        user.RefreshUnitsList();
        Array _Units = user.m_Units;
        if (0 == _Units.size())
                return;

        for ( int i = 0; i < _Units.size(); i++)
        {

            Component Soldier = new #GameController().GetObject(_Units[i]);
            if (null == Soldier)
                    return;

            Matrix _Pos = getPosition(Soldier);
            SoldierPosition.add(_Pos);
            //logError("[SavePosition] for unit ID=" + new String(_Units[i]));
            //logWarning("    SoldierPosition["+new String(i)+"]="+new String(SoldierPosition[i].origin));
            SoldierID.add(_Units[i]);
            //logWarning("    SoldierID["+new String(i)+"]="+new String(SoldierID[i]));
        }
        //SoldierPosBrighten = SoldierPosition;
        SoldierPosBrighten = CreatePositionBrighten();

        //logError("SoldierPosition=" + new String(SoldierPosition));
        //logError("SoldierID=" + new String(SoldierID));
        //logError("SoldierPosBrighten=" + new String(SoldierPosBrighten));
    }

    // регулировка скорости при перебежках

     event void    SpeedCorrection()
     {
         for( int i = 1; i < m_Units.size(); i++)
             GetUnitTask(m_Units[i]).ChangeMoveSpeed(rand(2.0, 4.0), rand(2.0, 4.0));
     }
     void Init()
     {
        SetImmortalMode(true);
        PersonalHelicID =    getIdentificator(user).GetPartPreceding("_DesantGroup");
        PersonalNavPointLoad = "";
        //SavePosition();
     }

     // fireEvent(0.0, [], "TeleportSoldier", []); fireEvent(0.0, [], "LoadDesant", []);
     event void TeleportSoldier()
     {
         //logWarning("Teleport american soldier!!");
         if (NavPointTeleport == "")
         {
            //logWarning("[TeleportSoldier] Point of teleport is empty!! Group with ID="+ getIdentificator(user));
            return;
         }
// не верно ...  SoldierID попробовать заменить на m_Units
         Matrix NewPos = getPosition((new #GameController()).GetObject(NavPointTeleport));
         for ( int i = 0; i < SoldierID.size(); i++)
         {
             Component Unit = new #GameController().GetObject(SoldierID[i]);
             if (Unit != null && !checkMask(Unit, [CLASSIFICATOR_DEAD_OBJECT], []))
             {
                 Component Soldier = new #GameController().GetObject(SoldierID[i]);
                 Component Behavior = GetUnitBehavior(SoldierID[i]);
                 if ( Behavior != null)
                 {
                     Behavior.SetPosition( NewPos );
                 }
             }
         }

        setPosition(user, NewPos);

        SetFormation("CFrontFormation", 2, true, true);
        sendEvent(rand(0.0, 10.0), getIdentificator(user), "MoveToPointBrighten", []);
     }

     event void MoveToPointBrighten()
     {
            for ( int i = 0; i < SoldierID.size(); i++)
            {
                Vector NewPos = SoldierPosition[i].origin;

                //logWarning("[MoveToPointBrighten] SoldierPosition["+ new String(i)+"].origin=" + new String(NewPos));

                InvokeUnitTaskFunction(m_Units[i],"SetOrder_MoveTo",[NewPos, 0.0 ]);
                GetUnitTask(m_Units[i]).ChangeMoveSpeed(rand(2.0, 4.0), rand(2.0, 4.0));
            }
     }

     event void UnloadHelicopter(String _Helic, String _NavPoint)
     {
         //logWarning("Groyp ID=" + getIdentificator(user) + " recived    event UnloadHelicopter");
         SetOrder_Unload( _Helic, _NavPoint, 500, 40);
     }

     event void LoadHelicopter(String _HelicID, String _NavPoint)
     {
         //logWarning("Group ID="+ getIdentificator(user) + " SetOrder_Load in Helic ID=" +_HelicID);
         SetOrder_Load(_HelicID, false, "LoadToTransportShortRunoffRight");
         m_CurrentOrder.m_MovingSpeed = 2.5f;

//         for( int i = 1; i < m_Units.size(); i++)
//             GetUnitTask(m_Units[i]).ChangeMoveSpeed(rand(1.0, 3.0));
     }

     event void LoadDesant()
     {
        SetFormation("Independent", 2, false, false);
/*
        if (getIdentificator(user) == "DesantGroup_5")
        {
            sendEvent( rand(5.0, 10.0), getIdentificator(user), "LoadHelicopter", [PersonalHelicID, PersonalNavPointLoad]);
        }
        else if (getIdentificator(user) == "DesantGroup_6")
        {
            sendEvent( rand(5.0, 10.0), getIdentificator(user), "LoadHelicopter", [PersonalHelicID, PersonalNavPointLoad]);
        }
        else if (getIdentificator(user) == "DesantGroup_7")
        {
            sendEvent( rand(5.0, 10.0), getIdentificator(user), "LoadHelicopter", [PersonalHelicID, PersonalNavPointLoad]);
        }
        else if (getIdentificator(user) == "DesantGroup_8")
        {
            sendEvent( rand(5.0, 10.0), getIdentificator(user), "LoadHelicopter", [PersonalHelicID, PersonalNavPointLoad]);
        }
        else
            sendEvent( rand(0.0, 5.0), getIdentificator(user), "LoadHelicopter", [PersonalHelicID, PersonalNavPointLoad]);
        */
        sendEvent( 0.0, getIdentificator(user), "LoadHelicopter", [PersonalHelicID, PersonalNavPointLoad]);
     }


     event void Tumbling(String SoldierID)
     {
         Component Unit = new #GameController().GetObject(SoldierID);
         Matrix NowPos = getPosition(Unit);
         //logWarning("Position " + new String(NowPos));
         Vector NowOrigin = NowPos.origin;
         vA.z=NowOrigin.z;
         vB.z=NowOrigin.z;
         vC.z=NowOrigin.z;
         NowPos.origin = new Vector(0.0,0.0,0.0);
         Vector vAB = vA - vB;
         Vector vBC = vB - vC;
         Vector Dir = getCrossProduct (getCrossProduct(vAB, vBC), vAB);
         Dir.Normalize();
         NowPos = (new Matrix(new Quaternion(NowPos.xvec,    Dir))) * NowPos;
         NowPos.origin = NowOrigin;
         //logWarning("Position " + new String(NowPos));

         if (InvokeUnitTaskFunction(SoldierID, "setPosition", [Unit, NewPos], true))
                logError("Unit with ID="+ SoldierID + "has not behaviour!!");
         //Unit.EnableBehavior(false, false);
         //setPosition(Unit, NowPos);
         //Unit.EnableBehavior(true, true);
     }

     event Vector MidPosition()
     {
         Vector vAB = vA - vB;
         float ABHalfMagnitude = vAB.Magnitude() * 0.5f;
         vAB.Normalize();
         return vB + vAB * ABHalfMagnitude;
     }

     event void OnUnloaded( String _TransportID)
     {
         CBaseUnitGroup::OnUnloaded(_TransportID);
         //logWarning("Group ID="+ getIdentificator(user) +    "    OnGroupUnloaded. Leader group ID=" + GetLeaderId());
         sendEvent( 5.0, GetLeaderId(), "MoveToFightPositionDesant", [MidPosition()]);
         //SetImmortalMode(true);
         GetMission().WingmanGroupRoost = false;
     }

    void DesantOnStoppedSoldier( Component _UnitTask)
    {
        //logWarning("[DesantOnStoppedSoldier] GroupID=" + getIdentificator(user));
        //logWarning("_UnitTask.IsWalkToFight =" + new String(_UnitTask.IsWalkToFight));
        DesantStartFight = true;
        if ( _UnitTask.IsWalkToFight == true)
        {
            _UnitTask.IsWalkToFight = false;
            sendEvent( 5.0, getIdentificator(user), "SavePosition", []);
            sendEvent( 8.0, getIdentificator(user), "Displacment", []);
            sendEvent( 20.0, getIdentificator(user), "ActivateMovement", [false]);
            //InvokeGroupTaskFunction(getIdentificator(user), "Displacment", []);
            SetImmortalMode(false);
        }
    }
 }

 class Plei_Me_Uh1d_1_DesantGroup extends DesantGroup
 {
    String PointBrighten = "NavPoint_AmericanResurrect_1";

    void Init()
    {
        DesantGroup::Init();
        sA = "AmericanSoldierGun_XRay_1_7";
        sB = "AmericanSoldierGun_XRay_2_3";
        sC = "NavPoint_XRay";

        Component A = GetMission().GetObject(sA);
        Component B = GetMission().GetObject(sB);
        Component C = GetMission().GetObject(sC);
        if ( A != null && B != null && C != null)
        {
            vA = getPosition(A).origin;
            vB = getPosition(B).origin;
            vC = getPosition(C).origin;
        }
        else
        {
            logError("Component A or B or C -- null! Do Not work formation soldier after debarkation!!!");
            vA = new Vector(0.0 ,0.0, 0.0);
            vB = new Vector(0.0 ,0.0, 0.0);
            vC = new Vector(0.0 ,0.0, 0.0);
        }
    }

    event void MoveToHelicopterAndLoad()
    {
        //logWarning("[MoveToHelicopterAndLoad] for group ID=" + getIdentificator(user));
        SetOrderName("");
        SetFormation("Column", 2, true, true);
        Array ApproachPoints = [GetNavPointBehPos("NavPoint_MoveToHelic1_1"),
                                                        GetNavPointBehPos("NavPoint_MoveToHelic1_2"),
                                                        GetNavPointBehPos("NavPoint_MoveToHelic1_3")
                                                        ];

        SetFirstQueueOrders([
                                                    ["MoveToHelic", "SetOrder_MoveToEx", [ApproachPoints, 3.5f], ""],
                                                    ["MoveToHelic", "LoadDesant", [], ""]
                                                ]);
    }
 }
 class Plei_Me_Uh1d_2_DesantGroup extends DesantGroup
 {
    String PointBrighten = "NavPoint_AmericanResurrect_1";

    void Init()
    {
        DesantGroup::Init();
        sA = "AmericanSoldierGun_XRay_2_7";
        sB = "AmericanSoldierGun_XRay_3_3";
        sC = "NavPoint_XRay";

        Component A = GetMission().GetObject(sA);
        Component B = GetMission().GetObject(sB);
        Component C = GetMission().GetObject(sC);
        if ( A != null && B != null && C != null)
        {
            vA = getPosition(A).origin;
            vB = getPosition(B).origin;
            vC = getPosition(C).origin;
        }
        else
        {
            logError("Component A or B or C -- null! Do Not work formation soldier after debarkation!!!");
            vA = new Vector(0.0 ,0.0, 0.0);
            vB = new Vector(0.0 ,0.0, 0.0);
            vC = new Vector(0.0 ,0.0, 0.0);
        }
    }

    event void MoveToHelicopterAndLoad()
    {
        //logWarning("[MoveToHelicopterAndLoad] for group ID=" + getIdentificator(user));
        SetOrderName("");
        SetFormation("Column", 2, true, true);
        Array ApproachPoints = [GetNavPointBehPos("NavPoint_MoveToHelic2_1"),
                                                        GetNavPointBehPos("NavPoint_MoveToHelic2_2"),
                                                        GetNavPointBehPos("NavPoint_MoveToHelic2_3")
                                                        ];

        SetFirstQueueOrders([
                                                    ["MoveToHelic", "SetOrder_MoveToEx", [ApproachPoints, 3.5f], ""],
                                                    ["MoveToHelic", "LoadDesant", [], ""]
                                                ]);
    }
 }
 class Plei_Me_Uh1d_3_DesantGroup extends DesantGroup
 {
    String PointBrighten = "NavPoint_AmericanResurrect_1";

    void Init()
    {
        DesantGroup::Init();
        sA = "AmericanSoldierGun_XRay_3_7";
        sB = "AmericanSoldierGun_XRay_4_3";
        sC = "NavPoint_XRay";

        Component A = GetMission().GetObject(sA);
        Component B = GetMission().GetObject(sB);
        Component C = GetMission().GetObject(sC);
        if ( A != null && B != null && C != null)
        {
            vA = getPosition(A).origin;
            vB = getPosition(B).origin;
            vC = getPosition(C).origin;
        }
        else
        {
            logError("Component A or B or C -- null! Do Not work formation soldier after debarkation!!!");
            vA = new Vector(0.0 ,0.0, 0.0);
            vB = new Vector(0.0 ,0.0, 0.0);
            vC = new Vector(0.0 ,0.0, 0.0);
        }
    }

    event void MoveToHelicopterAndLoad()
    {
        //logWarning("[MoveToHelicopterAndLoad] for group ID=" + getIdentificator(user));
        SetOrderName("");
        SetFormation("Column", 2, true, true);
        Array ApproachPoints = [GetNavPointBehPos("NavPoint_MoveToHelic3_1"),
                                                        GetNavPointBehPos("NavPoint_MoveToHelic3_2"),
                                                        GetNavPointBehPos("NavPoint_MoveToHelic3_3")
                                                        ];

        SetFirstQueueOrders([
                                                    ["MoveToHelic", "SetOrder_MoveToEx", [ApproachPoints, 3.0f], ""],
                                                    ["MoveToHelic", "LoadDesant", [], ""]
                                                ]);
    }
 }
 class Plei_Me_Uh1d_4_DesantGroup extends DesantGroup
 {
    String PointBrighten = "NavPoint_AmericanResurrect_1";
    String NavPointTeleport = "NavPoint_DesantGroup_4";
    void Init()
    {
        DesantGroup::Init();
        sA = "AmericanSoldierGun_XRay_4_7";
        sB = "AmericanSoldierGun_XRay_5_3";
        sC = "NavPoint_XRay";

        Component A = GetMission().GetObject(sA);
        Component B = GetMission().GetObject(sB);
        Component C = GetMission().GetObject(sC);
        if ( A != null && B != null && C != null)
        {
            vA = getPosition(A).origin;
            vB = getPosition(B).origin;
            vC = getPosition(C).origin;
        }
        else
        {
            logError("Component A or B or C -- null! Do Not work formation soldier after debarkation!!!");
            vA = new Vector(0.0 ,0.0, 0.0);
            vB = new Vector(0.0 ,0.0, 0.0);
            vC = new Vector(0.0 ,0.0, 0.0);
        }
    }

    event void MoveToHelicopterAndLoad()
    {
        //logWarning("[MoveToHelicopterAndLoad] for group ID=" + getIdentificator(user));
        SetOrderName("");
        SetFormation("Column", 2, true, true);
        Array ApproachPoints = [GetNavPointBehPos("NavPoint_MoveToHelic4_1"),
                                                        GetNavPointBehPos("NavPoint_MoveToHelic4_2"),
                                                        GetNavPointBehPos("NavPoint_MoveToHelic4_3")
                                                        ];

        SetFirstQueueOrders([
                                                    ["MoveToHelic", "SetOrder_MoveToEx", [ApproachPoints, 3.0f], ""],
                                                    ["MoveToHelic", "LoadDesant", [], ""]
                                                ]);
    }
 }
 class Plei_Me_Uh1d_5_DesantGroup extends DesantGroup
 {
    String PointBrighten = "NavPoint_AmericanResurrect_2";
    //String NavPointTeleport = "NavPoint_DesantGroup_5";
    void Init()
    {
        DesantGroup::Init();
        sA = "AmericanSoldierGun_XRay_5_7";
        sB = "AmericanSoldierGun_XRay_6_3";
        sC = "NavPoint_XRay";

        Component A = GetMission().GetObject(sA);
        Component B = GetMission().GetObject(sB);
        Component C = GetMission().GetObject(sC);
        if ( A != null && B != null && C != null)
        {
            vA = getPosition(A).origin;
            vB = getPosition(B).origin;
            vC = getPosition(C).origin;
        }
        else
        {
            logError("Component A or B or C -- null! Do Not work formation soldier after debarkation!!!");
            vA = new Vector(0.0 ,0.0, 0.0);
            vB = new Vector(0.0 ,0.0, 0.0);
            vC = new Vector(0.0 ,0.0, 0.0);
        }
    }

    event void TeleportSoldier()
    {
       logWarning("Special Teleport american soldier!!");
       RefreshUnitsList();
       for ( int i = 0; i < m_Units.size(); i++)
       {
           Component Unit = new #GameController().GetObject(m_Units[i]);
           if (Unit != null && !checkMask(Unit, [CLASSIFICATOR_DEAD_OBJECT], []))
           {
               Component Soldier = new #GameController().GetObject(m_Units[i]);
               Component Behavior = GetUnitBehavior(m_Units[i]);
               if ( Behavior != null)
               {
                  Matrix RootPos = getPosition(new #GameController().GetObject(PersonalHelicID));
                  RootPos.xvec = - RootPos.xvec;
                  RootPos.yvec = - RootPos.yvec;
                  Behavior.SetPosition(RootPos);
                  Unit.GetHumanAnimator().EnableControl(false);
                  Unit.GetObject("HeliLoadAnimator").EnableControl(true);
               }
           }
       }
    }

    event void MoveToHelicopterAndLoad()
    {
        //logWarning("[MoveToHelicopterAndLoad] for group ID=" + getIdentificator(user));
        SetOrder_SpecLoad(PersonalHelicID);
    }
 }
 class Plei_Me_Uh1d_6_DesantGroup extends DesantGroup
 {
    String PointBrighten = "NavPoint_AmericanResurrect_2";
    String NavPointTeleport = "NavPoint_DesantGroup_6";
    boolean MovoToAttack = false;
    void Init()
    {
        DesantGroup::Init();
        // other behaviour
            vA = new Vector(0.0 ,0.0, 0.0);
            vB = new Vector(0.0 ,0.0, 0.0);
            vC = new Vector(0.0 ,0.0, 0.0);
    }

    event void AmericanRezervAttack()
    {
        ActivateMovement(true);
        SetEnemyReactionType(ERT_PASSIVE);
        PopDelayedOrder();
        SetImmortalMode(true);
        MovoToAttack = true;
    }
     void OnPathEndReached()
     {
        if (MovoToAttack)
        {
            //logWarning("OnPathEndReached for    GroupUnit_AmericanAttack_XRay");
            SetFormation("CFrontFormation", 5, true, true);
            MovoToAttack = false;
        }
     }

    event void TeleportSoldier()
    {
       logWarning("Special Teleport american soldier!!");
       RefreshUnitsList();
       for ( int i = 0; i < m_Units.size(); i++)
       {
           Component Unit = new #GameController().GetObject(m_Units[i]);
           if (Unit != null && !checkMask(Unit, [CLASSIFICATOR_DEAD_OBJECT], []))
           {
               Component Soldier = new #GameController().GetObject(m_Units[i]);
               Component Behavior = GetUnitBehavior(m_Units[i]);
               if ( Behavior != null)
               {
                  Matrix RootPos = getPosition(new #GameController().GetObject(PersonalHelicID));
                  RootPos.xvec = - RootPos.xvec;
                  RootPos.yvec = - RootPos.yvec;
                  Behavior.SetPosition(RootPos);
                  Unit.GetHumanAnimator().EnableControl(false);
                  Unit.GetObject("HeliLoadAnimator").EnableControl(true);
               }
           }
       }
    }

    event void MoveToHelicopterAndLoad()
    {
        //logWarning("[MoveToHelicopterAndLoad] for group ID=" + getIdentificator(user));
        SetOrder_SpecLoad(PersonalHelicID);
    }
 }
 class Plei_Me_Uh1d_7_DesantGroup extends DesantGroup
 {
    String PointBrighten = "NavPoint_AmericanResurrect_2";
    String NavPointTeleport = "NavPoint_DesantGroup_7";
    boolean MovoToAttack = false;
    void Init()
    {
        DesantGroup::Init();
        // other behaviour
            vA = new Vector(0.0 ,0.0, 0.0);
            vB = new Vector(0.0 ,0.0, 0.0);
            vC = new Vector(0.0 ,0.0, 0.0);
    }

    event void AmericanRezervAttack()
    {
        ActivateMovement(true);
        SetEnemyReactionType(ERT_PASSIVE);
        PopDelayedOrder();
        SetImmortalMode(true);
        MovoToAttack = true;
    }
     void OnPathEndReached()
     {
        if (MovoToAttack)
        {
            //logWarning("OnPathEndReached for    GroupUnit_AmericanAttack_XRay");
            SetFormation("CFrontFormation", 5, true, true);
            MovoToAttack = false;
        }
     }

    event void MoveToHelicopterAndLoad()
    {
        //logWarning("[MoveToHelicopterAndLoad] for group ID=" + getIdentificator(user));
        SetOrderName("");
        SetFormation("Column", 2, true, true);
        Array ApproachPoints = [GetNavPointBehPos("NavPoint_MoveToHelic7_1")
                                                        ];

        SetFirstQueueOrders([
                                                    ["MoveToHelic", "SetOrder_MoveToEx", [ApproachPoints, 3.5f], ""],
                                                    ["MoveToHelic", "LoadDesant", [], ""]
                                                ]);
    }
 }
 class Plei_Me_Uh1d_8_DesantGroup extends DesantGroup
 {
    String PointBrighten = "NavPoint_AmericanResurrect_2";
    String NavPointTeleport = "NavPoint_DesantGroup_8";
    boolean MovoToAttack = false;
    void Init()
    {
        DesantGroup::Init();
        // other behaviour
            vA = new Vector(0.0 ,0.0, 0.0);
            vB = new Vector(0.0 ,0.0, 0.0);
            vC = new Vector(0.0 ,0.0, 0.0);
    }

    event void AmericanRezervAttack()
    {
        ActivateMovement(true);
        SetEnemyReactionType(ERT_PASSIVE);
        PopDelayedOrder();
        SetImmortalMode(true);
        MovoToAttack = true;
    }
     void OnPathEndReached()
     {
        if (MovoToAttack)
        {
            //logWarning("OnPathEndReached for    GroupUnit_AmericanAttack_XRay");
            SetFormation("CFrontFormation", 5, true, true);
            MovoToAttack = false;
        }
     }

    event void MoveToHelicopterAndLoad()
    {
        //logWarning("[MoveToHelicopterAndLoad] for group ID=" + getIdentificator(user));
        SetOrderName("");
        SetFormation("Column", 2, true, true);
        Array ApproachPoints = [GetNavPointBehPos("NavPoint_MoveToHelic8_1")
                                                        ];

        SetFirstQueueOrders([
                                                    ["MoveToHelic", "SetOrder_MoveToEx", [ApproachPoints, 3.5f], ""],
                                                    ["MoveToHelic", "LoadDesant", [], ""]
                                                ]);
    }
 }

 class DesantTask extends C1M2XrayAmericanTask
 {
     boolean IsWalkToFight = false;
     boolean IsMoveToRezerv = false;
     float _radius = 30.0;                 // с радиусом radius будут выбирать позицию около точки NavPoint_XRay_Rezerv
     String _NavPoint = "NavPoint_XRay_Rezerv";

     event void MoveToFightPositionDesant(Vector MidPoint)
     {
            // куда пойдут те у которых нету векторов
            if ((m_Group.vA).Magnitude() == 0 &&    (m_Group.vB).Magnitude() == 0)
            {
                Vector Pos = getPosition((new #GameController()).GetObject(_NavPoint)).origin;
                Vector NewPos = Pos + new Vector( rand(_radius), rand(_radius), 0.0);

                m_Group.SetOrientedFormation("Current", 5, true,true);
                m_Group.SetOrder_MoveTo( NewPos, 4.0, true);
                IsMoveToRezerv = true;
                return;
            }
         m_Group.SetOrientedFormation("CFrontFormation", 5, true,true);
         Vector MidPoint = m_Group.MidPosition();
         m_Group.SetOrder_MoveTo( MidPoint, 4.0, true);
         IsWalkToFight = true;
     }

     void OnStopped()
     {
         C1M2XrayAmericanTask::OnStopped();
         if (IsWalkToFight)
         {
             //logWarning("Soldier ID="+ getIdentificator(user) +    "    Call Tumbling.");
             //logWarning("Group ID=" + m_Group.m_GroupID);

             //sendEvent( 0.0, m_Group.GetLeaderId(), "Tumbling", [getIdentificator(user)]);

             // вызвать у группы чтобы там запомнить позицию, вычислить квадрат где будем перебегать и снять неуязвисмость
             InvokeGroupTaskFunction(m_Group.m_GroupID, "DesantOnStoppedSoldier", [GetUnitTask(getIdentificator(user))]);

         } else if (IsMoveToRezerv)
         {
             sendEvent(5.0, m_Group.m_GroupID, "ActivateMovement", [false]);
             //fireEvent(0.0, [], "AmericanRezervAttack", []);
             IsMoveToRezerv = false;
         }
     }
 }

 //    sendEvent(0.0, "MainPlayerUnit_Wingman_1", "DisconnectWingman", []);
 class WingmanTask extends CWingmanTask
 {
    boolean WingmanMoveToLand = false;
    boolean MoveToAttackMortar = false;

    void Init()
    {
     GetSelf().GetStateControl().SetImmortalMode(true);
    }


    event void StartWingman()
    {
        sendEvent(0.0, "MainPlayerUnit_Wingman_1", "TakeOff", []);
    }

    event void DisconnectWingman()
    {
        logWarning(" Wingman Disconnect");
        WingmanDisconnect();
        sendEvent(0.0, "MainPlayerUnit_Wingman_1", "MoveToAttackMortar", []);

        // GroupUnit_Vietnamese_XRayMotar_1
    }

    event void MoveTo()
    {
        SetOrder_MoveTo(GetNavPointBehPos("NavPoint_XRay"), 40.0);
        //SetOrder_MoveTo(GetNavPointBehPos("NavPoint_XRay"), 60.0);
    }

    event void MoveToAttackMortar()
    {
      logWarning("[WingmanTask::MoveToAttackMortar]");
      MoveToAttackMortar = true;
      Wingman_TakeOff();
      SetOrder_MoveTo(GetNavPointBehPos("NavPoint_MainPlayerUnit_Attack_1"), 10.0);
      //SetOrder_MoveTo(GetNavPointBehPos("NavPoint_XRay"), 60.0);
    }

    event void MoveToPointLand(float _Height, float _Speed)
    {
     logWarning("[MoveToPointLand::WingmanTask] event MoveToPointLand    HelicID=" + getIdentificator(user));
     logWarning("[MoveToPointLand::WingmanTask] _Height=" + new String(_Height) + "  _Speed=" + new String(_Speed));
      SetFrigidMode(true);
      WingmanMoveToLand = true;
      SetFlyingHeight(_Height);
      SetOrder_MoveTo( GetNavPointBehPos("NavPoint_Landing_Plei_Me_Wingman"), _Speed);
    }
    void OnStopped()
    {
     if (MoveToAttackMortar)
        {
          SetEnemyReactionType(ERT_PASSIVE);
          SetOrder_Attack("Vietnamese_XRayMortar_1", 15.0);
          MoveToAttackMortar = false;
        }
        if ( WingmanMoveToLand )
        {
           if (getIdentificator(user) == "Plei_Me_Uh1d_1")
                   sendEvent(0.0, SOID_MissionController, "StartDialog", ["ExchangePointLand"]);

           sendEvent(0.0, getIdentificator(user), "Landing", ["NavPoint_Landing_Plei_Me_Wingman"]);
           //sendEvent(10.0, getIdentificator(user) + "_DesantGroup", "UnloadHelicopter", [getIdentificator(user), "NavPoint_Landing_See_" + getIdentificator(user)]);
           WingmanMoveToLand = false;
        }

        CWingmanTask::OnStopped();
    }

    event void WingmanLastFly()
    {
        sendEvent(0.0, "MainPlayerUnit_Wingman_1", "DisconnectWingman", []);
    }
 }

class AmericanSkyRidersGroup_1 extends CBaseUnitGroup
{
    void Init()
    {
        CBaseUnitGroup::Init();
        ActivateGroup(false);
    }
    // called when Group queue orders is ended
    void OnQueueOrdersEnd(String _OrderGroupID, Component _UnitTask)
    {
        CBaseUnitGroup::OnQueueOrdersEnd(_OrderGroupID, _UnitTask);
        if (_OrderGroupID == "SpecialBombAttack")
        {
            _UnitTask.SetFrigidMode(true);
            _UnitTask.ActivateBehavior(false);
            _UnitTask.ShowUnit(false);
        }
    }

    //sendEvent(0.0, "GroupUnit_AmericanSkyRiders_1", "BombAttack", []);
    event void BombAttack()
    {
        ActivateGroup(true);

        SetOrderName("");
        //logError("Call BombAttack()");
        Array ApproachPoints = [GetNavPointBehPos("SkyRidersAttackNP_01"),
                                                        GetNavPointBehPos("SkyRidersAttackNP_02"),
                                                        GetNavPointBehPos("SkyRidersAttackNP_03")
                                                        ];

        SetFirstQueueOrders([
                                                    ["BombAttack", "SetOrder_MoveToEx", [ApproachPoints, 140.0f], ""],
                                                    ["BombAttack", "Bomben", [], ""]
                                                ]);

        // Behavior.SetOrder_BombAttack(GetNavPointBehPos("SkyRidersAttackNP_03"), Speed, Target, Time, AttackOut);
    }

    void Bomben()
    {
        //logError("Call Bomben()");
        float    Speed = 100.0;
        float    Time = 3.0;

        ClearFormation();
        String Target1 = "SkyRidersBombNPStart_01";
        String Target2 = "SkyRidersBombNPStart_02";
        Vector AttackOut1 = GetNavPointBehPos("SkyRidersBombNPEnd_01");
        Vector AttackOut2 = GetNavPointBehPos("SkyRidersBombNPEnd_02");

        Component Behavior1 = GetUnitBehavior("SkyRider_01");
        Component Behavior2 = GetUnitBehavior("SkyRider_02");

        if (Behavior1 != null && Behavior2 != null)
        {
            Behavior1.setOrder_SpecialBombAttack(Behavior1.GetNowPosition(), Speed, Target1, Time, AttackOut1);
            Behavior2.setOrder_SpecialBombAttack(Behavior2.GetNowPosition(), Speed, Target2, Time, AttackOut2);
        }
    }
}

class AmericanSkyRidersGroup_1_tv extends CBaseUnitGroup
{
    void Init()
    {
        CBaseUnitGroup::Init();
        ActivateGroup(false);
    }

    // called when Group queue orders is ended
    void OnQueueOrdersEnd(String _OrderGroupID)
    {
        CBaseUnitGroup::OnQueueOrdersEnd(_OrderGroupID);
        if (_OrderGroupID == "BomberFly")
                    ActivateGroup(false);

    }

    //sendEvent(0.0, "GroupUnit_AmericanSkyRiders_1_tv", "StartFly", []);
    event void StartFly()
    {
        Array ApproachFlyPoints = [GetNavPointBehPos("SkyRidersPatrolNP_01"),
                                                             GetNavPointBehPos("SkyRidersPatrolNP_02"),
                                                             GetNavPointBehPos("SkyRidersPatrolNP_03"),
                                                             //GetNavPointBehPos("SkyRidersPatrolNP_04"),
                                                             GetNavPointBehPos("SkyRidersPatrolNP_05")
                                                            ];

        ActivateGroup(true);

        SetFirstQueueOrders([
                                                    ["BomberFly", "SetOrder_MoveToEx", [ApproachFlyPoints, 130.0f], ""],
                                                    ["", "ActivateGroup", [false] , ""]
                                                ]);
    }
}

 class SkyRiderTask extends CBaseAITask
 {
  boolean _detonate = false;

  // sendEvent(0.0, SOID_MissionController, "OnBombDetonate", [IdentityMatrix]);
   event void OnBombDetonate(Matrix _Position)
   {
    if (!_detonate)
    {
      if ( !GetMission().SkyRiderDetect)
      {
        sendEvent(0.0, SOID_MissionController, "OnMissionDialogEnd", ["BombersOnCourse"]);
      }


      logError("[OnBombDetonate] UnitID=" + getIdentificator(user));

      sendEvent( 10.0, SOID_MissionController, "AllGroupPopDelayedOrder", []);

      addClassificatorObject( "MainPlayerUnit", GetMission().PlayerSpin );
      removeClassificatorObject( "MainPlayerUnit", GetMission().PlayerForward );
      addClassificatorObject( "MainPlayerUnit", GetMission().PlayerBack );

    //TMP
    Component console = new #GameController().GetObject(SOID_Console);
    console.logClassificatorsList("MainPlayerUnit");
    //TMP

      if (GetMission().GetObject("MainPlayerUnit").GetSecondPilot().IsEnabledAutopilot())
         sendEvent( 20.0, SOID_MissionController, "StartAutoPilot", []);
    }
   }
 }


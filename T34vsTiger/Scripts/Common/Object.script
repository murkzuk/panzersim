//-------------------------------------------------------------------
//
//  This code is copyright 2001 by G5 Software.
//  Any unauthorized usage, either in part or in whole of this code
//  is strictly prohibited. Violators WILL be prosecuted to the
//  maximum extent allowed by law.
//
//-------------------------------------------------------------------

//
// CEffectDescr
//

class CEffectDescr
{
  CEffectDescr(
      int     _EffectID,
      String  _LogicType
    )
  {
    EffectID  = _EffectID;
    LogicType = _LogicType;
  }

  boolean CheckMask(
      String _Restrict,
      String _Exclude
    )
  {
    return ("" == _Restrict || LogicType == _Restrict) &&
           ("" == _Exclude  || LogicType != _Exclude);
  }

  int     EffectID  = INVALID_EFFECT_ID;
  String  LogicType = "";
}

//
// CObject
//

class CObject
  extends IObject, CEditable, ISerializeable, CBaseUtilities
{
  // Label of this object
  static String Label                      = "";

  // Automatic classificators of this object
  static Array AutomaticClassificators     = [];

  // ======================================
  // Default object properties
  // ======================================

  static float  DefaultHitPoints               = -1.0;
  static String DefaultSurfaceControl          = "None";
  static float  DefaultPutonWaterStability     = 0.0f;
  static Array  DefaultRoute                   = [];
  static float  DefaultShadowPlaneOffset       = 0.05f;
  static float  DefaultFakeShadowOffset        = 0.09f;
  static float  DefaultShadowLodShift          = 0.0f;
  static String DefaultAffiliation             = "NEUTRAL";
  static String DefaultHealthParameter         = "HP_HEALTHY";
  static int    UnitMenacePower                = MENACE_UNARMED;  // no menace by default

  static Array  PrevExplosionID                = [];
  static Array  PrevDeathEffect                = [];
  static String PrevDeathSound                 = "";

  final static float  DeathEffectDelay         = 0.0;

  static int CrashedStateChangeDelay           = 0.0;

  static Array  PostExplosionID                = [];
  static Array  PostDeathEffect                = [];
  static String PostDeathSound                 = "";
  static Array  LandingJoints                  = ["GroundLevel"];


  static Array  m_SyncAnimators;

  final static boolean DefaultShowInCinema     = true;
  final static boolean DefaultShowInGame       = true;

  // ======================================
  // Object properties
  // ======================================

  boolean   m_ShowInCinema          = DefaultShowInCinema;
  boolean   m_ShowInGame            = DefaultShowInGame;

  float     m_MaxHitPoints;
  boolean   m_IsAlive               = true;
  boolean   m_IsVisible             = true;
  boolean   m_IsEnabled             = true;
  boolean   m_IsMirror              = false;

  Array     m_Route                 = [];
  Array     m_ChildMissionObjects   = [];

  Array     m_WeaponList            = [];
  Array     m_WeaponNames           = [];

  String    m_PointHostID           = "";
  String    m_ObjectHostID          = "";

  String    m_CurSound              = "";
  String    m_CurPhrase             = "";
  Component m_Dialog;

  Component m_DeathAnimator         = null;

  Array     m_EffectsIdList         = [];

  float     ShadowPlaneOffset       = 0.0f;
  float     FakeShadowOffset        = 0.0f;

  String    NumberMaterialName      = "";

  // Physics items
  Array     m_ItemsList             = [];
  boolean   m_CanChangeView         = true;
  
  boolean   m_CanChangeViewTo3rd    = true;

  float     m_FrontAlarmAngle       = Math_HALFPI*0.8f;
  boolean   m_PassiveUnit           = false;

  // ======================================
  // Contruction and initialization
  // ======================================

  void CObject()
  {
   ShadowPlaneOffset = DefaultShadowPlaneOffset;
   FakeShadowOffset  = DefaultFakeShadowOffset;
    // Classify object
    for (int i = 0; i < AutomaticClassificators.size(); i++)
      addClassificator(user, AutomaticClassificators[i]);

    m_MaxHitPoints = DefaultHitPoints;
  }

  // ======================================
  // IObject Interface functions
  // ======================================

  void Construct(
      Component _Mission,
      Component _PropMap
    )
  {
    // Set unit affiliation
    String Affiliation = _PropMap.Get("Affiliation", "NEUTRAL");
    SetAffiliation(Affiliation);

    // Setup unit state control and set hit points
    m_MaxHitPoints = _PropMap.Get("HitPoints", DefaultHitPoints);
    SetupStateControl(m_MaxHitPoints);

    // Setup specific damage handler by unit
    SetupDamageHandler();

    // Set object on surface
    SetSurfaceControl(_PropMap.Get("SurfaceControl", DefaultSurfaceControl));

    Component Game = new #GameController();
    boolean IsMirror = _PropMap.Get("IsMirror",
        (Game.GetGameMode() == "Client"));

    if(IsMirror)
    {
        _PropMap.Set("IsManual", false);
        _PropMap.Set("IsPlayer", false);
    }
  }

  void Initialize(
      Component _Mission,
      Component _PropMap
    )
  {
    Component Game = new #GameController();
    Component Mission = Game.GetLoadedMission();
    if (Game.GetGameMode() != "Single")
    {

      boolean IsMirror = _PropMap.Get("IsMirror",
        (Game.GetGameMode() == "Client"));

      m_IsMirror = IsMirror;

      if(IsMirror)
      {
         _PropMap.Set("IsManual", false);
         _PropMap.Set("IsPlayer", false);
      }

      // Set special classificators
      if (IsMirror)
        addClassificator(user, "MIRRORMODE");
      else
        addClassificator(user, "HOSTMODE");

      //addClassificator(user, "MULTIPLAYERUNIT");

      boolean IsUnit = _PropMap.Get("IsUnit",false);
      if(IsUnit)
        addClassificator(user, "MULTIPLAYERUNIT");

      // Set mirror mode for unit state control
      Component StateControl = GetObject("StateControl");
      if (StateControl != null)
        StateControl.SetMirrorMode(IsMirror);

      // Set mirror mode for weapons
      for (int Weapon = 0; Weapon < m_WeaponList.size(); Weapon++)
        m_WeaponList[Weapon].SetMirrorMode(IsMirror);

      // Set mirror mode for collision control
      Component CollisionControl = GetObject("CollisionControl");
      if (CollisionControl != null)
        CollisionControl.SetMirrorMode(IsMirror);

      Component Behavior = GetObject("Behavior");
      if (Behavior != null)
        Behavior.SetMirrorMode(IsMirror);

      if(IsUnit || Behavior != null)
      {
      //Component ManualControl = GetManualControl();
        Component PositionSynchronize = new #ObjectPositionSynchronize();
        //logWarning("Set ManualControl");
        RegisterObject("PositionSynchronize", PositionSynchronize);
        setSlaveObject(PositionSynchronize, this);
        PositionSynchronize.EnableControl(true);
        if (PositionSynchronize != null)
          PositionSynchronize.SetMirrorMode(IsMirror);
      }      

      Component DamageHandler = GetDamageHandler();
      if(DamageHandler != null && IsSpecialDamageHandler())
        DamageHandler.SetMirrorMode(IsMirror);
    }
    
    addClassificator(user, "CAMERA_COLLISION");
    // Set all other properties
    SetProperties(_PropMap);

    // Initially enable/disable behavior according to mission status
    EnableBehavior(_Mission.IsBehaviorActive, false);
  }

  void Shutdown(
      Component _Mission
    )
  {
    // $TODO
  }

  Array GetDefaultProperties()
  {
    Array Default = [];

    Default.append([
        [ "HitPoints",         DefaultHitPoints      ],
        [ "SurfaceControl",    DefaultSurfaceControl ],
        [ "Affiliation",       DefaultAffiliation    ],
        [ "Route",             DefaultRoute          ],
        [ "ShadowPlaneOffset", ShadowPlaneOffset     ],
        [ "FakeShadowOffset",  FakeShadowOffset      ]        
      ]);

    return Default;
  }

  Array GetPropStrings()
  {
    return [
        [ "SurfaceControl", [ "None", "PutonGround", "PutonGroundUpright", "PutonGroundLandingJoints", "PutonWater" ] ]
      ];
  }

  void SetProperties(
      Component _PropMap
    )
  {
    // ручки для теней
    Component Mesh = GetMeshComponent();
    if (Mesh != null)
    {
      Mesh.SetShadowPlaneOffset(_PropMap.Get("ShadowPlaneOffset", DefaultShadowPlaneOffset));
      Mesh.SetFakeShadowOffset (_PropMap.Get("FakeShadowOffset",  DefaultFakeShadowOffset));
      //Mesh.SetShadowLodShift   (_PropMap.Get("ShadowLodShift",    DefaultShadowLodShift));
    }

    // Set health params
    String HealthParameter = _PropMap.Get("HealthParameter", DefaultHealthParameter);
    SetHealthParameter(HealthParameter);

    // Set menace power
    int MenacePower = _PropMap.Get("MenacePower", UnitMenacePower);
    SetMenacePower(MenacePower);

    // Set unit route
    m_Route = _PropMap.Get("Route", DefaultRoute);

    // Set weapons to behavior
    Component Behavior = GetBehavior();
    if (Behavior != null)
    {
      Behavior.SetWeaponList(m_WeaponList);
      SetBehRadarMask(Behavior, _PropMap);

      // mission tasks
      String DefaultMissionTask = "";
      if (_PropMap.Get("LeaderID", "") != "")
        DefaultMissionTask = "CWingmanTask";
      DefaultMissionTask = _PropMap.Get("Task", DefaultMissionTask);
      if (DefaultMissionTask != "")
        Behavior.SetMissionTask(DefaultMissionTask);

      Component Task = Behavior.GetTaskScriptHost();
      if (Task != null)
      {
        String HomePoint = "";
        HomePoint = _PropMap.Get("HomePoint", "" );
        if (HomePoint != "")
          Task.SetHomePoint(HomePoint);

        String EnemyReactionType = _PropMap.Get("EnemyReactionType", "ERT_PASSIVE");
        int ERT;
        if (EnemyReactionType == "ERT_AGGRESSIVE" )
          ERT = ERT_AGGRESSIVE;
        else if (EnemyReactionType == "ERT_FRIGID")
          ERT = ERT_FRIGID;
        else
          ERT = ERT_PASSIVE;
        Task.SetEnemyReactionType(ERT);
      }
    }

    m_MaxHitPoints = _PropMap.Get("HitPoints", DefaultHitPoints);
    SetSurfaceControl(_PropMap.Get("SurfaceControl", DefaultSurfaceControl));

    m_ShowInCinema = _PropMap.Get("ShowInCinema", DefaultShowInCinema);
    m_ShowInGame   = _PropMap.Get("ShowInGame", DefaultShowInGame);
    if (!m_ShowInGame)
      setVisibleState(GetMeshComponent(), false);

    Array AmmoQty = _PropMap.Get("AmmoQty", []);
    for (int i = 0; i < AmmoQty.size(); i++)
    {
      m_WeaponList[AmmoQty[i][0]].SetAmmoQuantity(AmmoQty[i][1], AmmoQty[i][2]);
    }
  }

  void Finalize(
      Component _Mission,
      Component _PropMap
    )
  {
    // Initialize unit state control
    FinilizeStateControl(_PropMap);

    Component Behavior = GetBehavior();
    if (Behavior != null)
    {
      if (!Behavior.Init(_Mission.GetMissionRouterZoneMap(),
                         _Mission.GetMissionTerrain(),
                         _Mission.GetRouterPrecalculatedGraph()
                       ))
        RemoveBehavior();
      else
      {
//        Vector BoundingSize = getBoundingSize(GetMeshComponent());
        _Mission.GetObject("UnitsCollisionControl").RegisterObject(GetMeshComponent(), Behavior, 2.5f, m_FrontAlarmAngle, m_PassiveUnit);
      }
    }

  }

  WString GetLabel(
      Component _Joint
    )
  {
    // $TODO
    return L"";
  }

  // ======================================
  // Mesh functions
  // ======================================

  void SetupMesh(
      Component _Mesh
    )
  {
    RegisterObject("Mesh", _Mesh);
    SetPositionProvider(_Mesh);
    addClassificator(_Mesh, "MainMesh");
    addClassificator(_Mesh, "CAMERA_COLLISION");

    Component Materials = _Mesh.GetMaterials();
    if (null != Materials)
      Materials.LoadPhysicsTable(CSubstances::PhysicsTable);
  }

  void SetupMesh(
      Component _Mesh,
      Array     _Lods
    )
  {
    SetupMesh(_Mesh);
    _Mesh.SetLods(_Lods);
  }

  void SetupCrashMesh(
      Component _Mesh,
      Array     _SyncAnimators
    )
  {
    m_SyncAnimators = _SyncAnimators;
    RegisterObject("CrashMesh", _Mesh);
    setVisibleState(_Mesh, false);
  }

  Component GetBoundingInfo()
  {
    return GetObject("Mesh");
  }

  Component GetMeshComponent()
  {
    return GetObject("Mesh");
  }

  // ======================================
  // State control methods
  // ======================================

  void SetupStateControl(
      float _HitPoints
    )
  {
    m_MaxHitPoints = _HitPoints;

    // Create state control component
    Component StateControl = new #UnitStateControl2();

    // Initialize state control
    StateControl.SetEventHandler(this);
    StateControl.SetHitPoints(_HitPoints);
    RegisterObject("StateControl", StateControl);
  }

  Component GetStateControl()
  {
    return GetObject("StateControl");
  }

  boolean GetImmortalMode()
  {
    return GetStateControl().GetImmortalMode();
  }

  event void SetImmortalMode(
      boolean _Mode
    )
  {
    GetStateControl().SetImmortalMode(_Mode);
  }

  void OnLifeStateChanged(
      boolean _IsAlive
    )
  {
    // check if this is destructible
    if (-1.0 == m_MaxHitPoints)
      return;

    if (!_IsAlive)
    {
//      if(checkMask(this, [], [CLASSIFICATOR_DEAD_OBJECT]))
        sendEvent(0.0, getIdentificator(this), "DestroyObject", []);
    }
    else
      sendEvent(0.0, getIdentificator(this), "RestoreObject", []);
  }

  event void DestroyObject()
  {
    logMessage(getIdentificator(this) + ": DestroyObject");

    Component VehicleController = GetObject("VehicleController");
    if (null != VehicleController)
      VehicleController.EnableEngine(false);

    Component WeaponSelector = GetObject("WeaponSelector");
    if (WeaponSelector != null)
    {
      WeaponSelector.InputEnable(false);
      m_BlockInput = true;
    }

    RemoveManualControl();
    for (int i = 0; i < m_WeaponList.size(); i++)
    {
      if (isFunctionExist(m_WeaponList[i], "Disable", 0))
        m_WeaponList[i].Disable();
    }

    if(checkMask(this, [], [CLASSIFICATOR_DEAD_OBJECT]))
    {
      // Set dead classificator
      logMessage(getIdentificator(this) + ": addClassificator DEAD_OBJECT");
      addClassificator(this, CLASSIFICATOR_DEAD_OBJECT);
      sendEvent(0.0, getIdentificator(GetMission()), "OnObjectDestroyed", [getIdentificator(this)]);
    }

    // Create explosions
    if (!PrevExplosionID.isEmpty())
    {
      Component ExplosonsArray = new #ExplosionsArray();
      for (int i = 0; i < PrevExplosionID.size(); i++)
      {
        ExplosonsArray.CreateExplosion(
          PrevExplosionID[i][1], GetPositionOfItem(PrevExplosionID[i][0]), null, getIdentificator(this));
      }
    }

    // Create death effects & sound
    if (!PrevDeathEffect.isEmpty())
    {
      Component EffectsArray = new #EffectsArray();
      for (int i = 0; i < PrevDeathEffect.size(); i++)
      {
        EffectsArray.CreateEffect(
          PrevDeathEffect[i][1], GetPositionOfItem(PrevDeathEffect[i][0]), this);
      }
    }

    if ("" != PrevDeathSound)
      (new #SoundsArray()).
        CreateSound(PrevDeathSound, getPosition(this));

    // clear events scheduled earlier for this object
    clearEventsForObject(getIdentificator(this));
    // Send destruction event
    //if (m_CanChangeView)
    sendEvent(0.0, getIdentificator(this), "OnObjectDestroyed", [getIdentificator(this)]);

    // Delay between preveffects and posteffects
    PlayDestroyAnimation();

    // get beh component
    Component Behavior = GetBehavior();
    if (Behavior != null)
    {
      // deactivate beh
      Behavior.ActivateBehavior(false);
    }

    // Set Destroyed unit state
    //SetState(STATE_Destroyed, US_Destroyed);
  }

  event void RestoreObject()
  {
    logMessage(getIdentificator(this) + ": RestoreObject");

    // restore classificators
    removeClassificator(this, CLASSIFICATOR_DEAD_OBJECT);

    // Send restore event
    sendEvent(0.0, getIdentificator(GetMission()), "OnObjectRestored", [getIdentificator(this)]);
    sendEvent(0.0, getIdentificator(this), "OnObjectRestored", [getIdentificator(this)]);

    // Set model state
    SetModelLifeState(true);

    // Set Destroyed unit state
    //SetState(STATE_Destroyed, US_Normal);

    // restore hitpoints
    Component StateControl = GetObject("StateControl");
    StateControl.SetHitPoints(m_MaxHitPoints);

    // get beh component
    Component Behavior = GetBehavior();
    boolean IsMirror = (new #GameController()).GetGameMode() != "Server";
    if (Behavior != null && IsMirror() == false)
    {
      // activate beh
      Behavior.ActivateBehavior(true);
    }
  }

  event void SetModelLifeState(
      boolean   _State
    )
  {
    logMessage(getIdentificator(this) + ": SetModelLifeState");
    m_IsAlive = _State;

    sendEvent(0.0,
      getIdentificator(this), "SetModelViewState", [_State]);
  }

  void PlayDestroyAnimation()
  {
    logMessage(getIdentificator(this) + ": PlayDestroyAnimation");
    // $TODO
    float Delay = DeathEffectDelay;
    sendEvent(Delay, getIdentificator(this), "DestroyProcess", []);
  }

  event void ShowObject(
      boolean _State
    )
  {
    Component Mesh = GetMeshComponent();
    if (Mesh == null)
      return;

    m_IsVisible = _State;

    setVisibleState(Mesh, _State);
  }

  event void SetModelViewState(
      boolean _State
    )
  {
    logMessage(getIdentificator(this) + ": SetModelViewState");
    Component Mesh = GetMeshComponent();
    if (Mesh == null)
     Mesh = GetObject("Mesh");
    if (Mesh == null)
    {
      logWarning(getIdentificator(this) + "can't get mesh component");
      return;
    }

    Component CrashJoint   = Mesh.GetJoint("crash");
    Component CrashedJoint = Mesh.GetJoint("crashed");
    Component CrashModel   = GetObject("CrashMesh");

    logWarning("SetModelViewState Joint is not connected");
    // $TODO

    if (_State)
    {
      setVisibleState(Mesh.GetRootJoint(), _State);

      if (CrashJoint != null)
        setVisibleState(CrashJoint, !_State);
      if (CrashedJoint != null)
        setVisibleState(CrashedJoint, !_State);
      UpdateVisibleState();
    }
    else
    {
      setVisibleState(Mesh.GetRootJoint(), _State);
      if (CrashJoint != null)
        setVisibleState(CrashJoint, _State);
      if (CrashedJoint != null)
        setVisibleState(CrashedJoint, !_State);
    }
  }

  void OnHideMesh()
  {
  }

  event void SetCrashed()
  {
    if (DeathEffectDelay == 0.0)
      sendEvent(DeathEffectDelay, getIdentificator(this), "DestroyProcess", []);
  }

  event void DestroyProcess()
  {
    logMessage(getIdentificator(this) + ": DestroyProcess");
    // Create explosions
    if (!PostExplosionID.isEmpty())
    {
      Component ExplosonsArray = new #ExplosionsArray();
      for (int i = 0; i < PostExplosionID.size(); i++)
      {
        ExplosonsArray.CreateExplosion(
          PostExplosionID[i][1], GetPositionOfItem(PostExplosionID[i][0]), null, getIdentificator(this));
      }
    }

    // Create death effects & sound
    if (!PostDeathEffect.isEmpty())
    {
      Component EffectsArray = new #EffectsArray();
      for (int i = 0; i < PostDeathEffect.size(); i++)
      {
        EffectsArray.CreateEffect(
          PostDeathEffect[i][1], GetPositionOfItem(PostDeathEffect[i][0]), this);
      }
    }

    if ("" != PostDeathSound)
      (new #SoundsArray()).
        CreateSound(PostDeathSound, getPosition(this));

    // clear events scheduled earlier for this object
    clearEventsForObject(getIdentificator(this));

    // Send destruction event
    if(checkMask(this, [], [CLASSIFICATOR_DEAD_OBJECT]))
    {
      sendEvent(0.0, getIdentificator(GetMission()), "OnObjectDestroyed", [getIdentificator(this)]);
      sendEvent(0.0, getIdentificator(this), "OnObjectDestroyed", [getIdentificator(this)]);
    }

    sendEvent(CrashedStateChangeDelay, getIdentificator(this), "SetModelLifeState", [false]);
  }

  event void UpdateVisibleState()
  {
    // Get mesh
    Component Mesh = GetMeshComponent();
    if (Mesh == null)
      return;

    setVisibleState(Mesh, IsVisible());
    fireEvent(0.0, [], "OnObjectVisibleStateChanged", [getIdentificator(user)]);

  }

  boolean IsVisible()
  {
    return m_IsVisible && m_IsEnabled;
  }

  void SetGroupRenderUsage(
      Component _Mesh,
      Array     _Joints,
      boolean   _Usage
    )
  {
    for (int i = 0; i < _Joints.size(); i++)
    {
      _Mesh.EnableJoint(
          _Joints[i],
          JOINT_USAGE_RENDER,
          0,
          _Usage
        );
    }
  }

  // ======================================
  // Damage handler methods
  // ======================================

  void SetupDamageHandler()
  {
    // Create damage handler
    Component DamageHandler;
    if (!IsSpecialDamageHandler())
      DamageHandler = new #UnitDamageHandler();
    else
    {
      DamageHandler = new #UnitDamageHandler2();

      // $TMP
      setPositionable(DamageHandler, GetMeshComponent());

      // Initialize armour
      Array ArmourDescriptor = GetArmourDescriptor();
      for (int i = 0; i < ArmourDescriptor.size(); i++)
        DamageHandler.SetSubstanceDamageModifier(
           ArmourDescriptor[i][0],
           ArmourDescriptor[i][1][0] / 100.0f,
           ArmourDescriptor[i][1][1] / 100.0f,
           ArmourDescriptor[i][1][2]
         );
    }

    // Setup handler
    DamageHandler.SetEventHandler(this);
    DamageHandler.SetStateControl(GetStateControl());
    RegisterObject("DamageHandler", DamageHandler);
  }

  Component GetDamageHandler()
  {
    return GetObject("DamageHandler");
  }

  boolean IsSpecialDamageHandler()
  {
    return isFunctionExist(this, "GetArmourDescriptor", 0);
  }

  // ======================================
  // Setup crash animator
  // ======================================

  void SetupCrashAnimator(
      Component _Animator
    )
  {
    setSlaveObject(_Animator, GetMeshComponent());
    RegisterObject("CrashAnimator", _Animator);
  }

  Component GetCrashAnimator()
  {
    Component Animator = GetObject("CrashAnimator");
    if (Animator == null)
      return null;

    return Animator;
  }

  // ======================================
  // Ground / water controls
  // ======================================

  Component GetSurfaceControl()
  {
    return GetObject("SurfaceControl");
  }

  void SetSurfaceControl(
      String _SurfaceControl
    )
  {
   //$TMP
   // if (getIdentificator(this) != "AmericanSoldierGun_XRay_4_1")
   // {
   //   EnableSurfaceControl(false);
   //   return;
   // }

    if ("None" == _SurfaceControl)
    {
      EnableSurfaceControl(false);
    }
    else
    if ("PutonGround" == _SurfaceControl)
    {
      PutonGround();
      EnableSurfaceControl(true);
    }
    else
    if ("PutonGroundUpright" == _SurfaceControl)
    {
      PutonGroundUpright();
      EnableSurfaceControl(true);
    }
    else
    if ("PutonGroundLandingJoints" == _SurfaceControl)
    {
      PutonGround(LandingJoints);
      EnableSurfaceControl(true);
    }
    else
    if ("PutonWater" == _SurfaceControl)
    {
      PutonWater(DefaultPutonWaterStability);
      EnableSurfaceControl(true);
    }
  }

  Component SetupSurfaceControl()
  {
    Component SurfaceControl = GetSurfaceControl();
    if (SurfaceControl != null)
      return SurfaceControl;

    SurfaceControl = new #SurfaceControl();
    setSlaveObject(SurfaceControl, GetMeshComponent());
    RegisterObject("SurfaceControl", SurfaceControl);
    if (checkMask(GetMeshComponent(), [CLASSIFICATOR_WALK_SURFACE], []))
      SurfaceControl.SetSurfaceMask([], [getIdentificator(user)]);
    return SurfaceControl;
  }

  void RemoveManualControl()
  {
    Component ManualControl       = GetObject("ManualControl");
    Component ManualObjectControl = GetObject("ManualObjectControl");
    if (null != ManualControl)
    {
      ManualControl.EnableControl(false);
      UnregisterObject("ManualControl");
    }

    if (null != ManualObjectControl)
    {
      ManualObjectControl.EnableControl(false);
      UnregisterObject("ManualObjectControl");
    }
  }

  void RemoveSurfaceControl()
  {
    Component SurfaceControl = GetSurfaceControl();
    if (null != SurfaceControl)
      UnregisterObject("SurfaceControl");
  }

  Matrix EnableSurfaceControl(boolean _Enable)
  {
    Component SurfaceControl = GetSurfaceControl();

    if (SurfaceControl == null)
        return;

    SurfaceControl.EnableSurfaceControl(_Enable);
    return SurfaceControl.GetCorrectedPosition();
  }

  Component PutonGround()
  {
    Component SurfaceControl = SetupSurfaceControl();

    SurfaceControl.SetUprightMode(false);
    SurfaceControl.SetGroundMode(true);
    SurfaceControl.SetWaterMode(false);
    SurfaceControl.SetCheckPointShift(new Vector(0.0, 0.0, 1000.0));
    SurfaceControl.SetWaveStability(0.0);

    return SurfaceControl;
  }

  // Joints must be setted in CCW mode
  Component PutonGround(
      Array _LandingJoints
    )
  {
    Component SurfaceControl = PutonGround();
    SurfaceControl.SetGearJoints(GenerateJointsList(_LandingJoints));
    return SurfaceControl;
  }

  Component PutonGroundUpright()
  {
    Component SurfaceControl = SetupSurfaceControl();

    SurfaceControl.SetUprightMode(true);
    SurfaceControl.SetGroundMode(true);
    SurfaceControl.SetWaterMode(false);
    SurfaceControl.SetCheckPointShift(new Vector(0.0, 0.0, 1000.0));
    SurfaceControl.SetWaveStability(0.0);

    return SurfaceControl;
  }

  Component PutonGroundAndWater(
      float _Stability
    )
  {
    Component SurfaceControl = SetupSurfaceControl();

    SurfaceControl.SetUprightMode(false);
    SurfaceControl.SetGroundMode(true);
    SurfaceControl.SetWaterMode(true);
    SurfaceControl.SetCheckPointShift(new Vector(0.0, 0.0, 1000.0));
    SurfaceControl.SetWaveStability(_Stability);

    return SurfaceControl;
  }

  Component PutonGroundAndWater(
      float _Stability,
      Array _GearJoints
    )
  {
    Component SurfaceControl = PutonGroundAndWater(_Stability);
    SurfaceControl.SetGearJoints(GenerateJointsList(_GearJoints));
    return SurfaceControl;
  }

  Component PutonWater(
      float _Stability
    )
  {
    Component SurfaceControl = SetupSurfaceControl();

    SurfaceControl.SetUprightMode(false);
    SurfaceControl.SetGroundMode(false);
    SurfaceControl.SetWaterMode(true);
    SurfaceControl.SetWaveStability(_Stability);
    SurfaceControl.SetSurfaceMask([CLASSIFICATOR_TERRAIN], []);

    Component Mesh = GetMeshComponent();
    Component WaterLine = Mesh.GetJoint("WaterLine");
    if (WaterLine == null)
    {
      logWarning("WaterLine joint not found");
      WaterLine = Mesh;
    }

    setPositionable(SurfaceControl, WaterLine);

    return SurfaceControl;
  }

  // ======================================
  // Behavior
  // ======================================

  void SetupHatches(
    Component _Hatches
  )
  {
    Component Mesh = GetMeshComponent();
    if (Mesh == null)
    {
      logError("Unable to setup Behavior, no Mesh object");
      return;
    }

    if (_Hatches == null)
    {
      logError("Unable to setup Behavior, null object");
      return;
    }

    setSlaveObject(_Hatches, Mesh);

    RegisterObject("Hatches", _Hatches);
  }

  void SetupBehavior(
      Component _Behavior
    )
  {
    Component Mesh = GetMeshComponent();
    if (Mesh == null)
    {
      logError("Unable to setup Behavior, no Mesh object");
      return;
    }

    if (_Behavior == null)
    {
      logError("Unable to setup Behavior, null object");
      return;
    }

    setSlaveObject(_Behavior, Mesh);
    _Behavior.SetSelf(this);

    RegisterObject("Behavior", _Behavior);
    SetRadarProvider(_Behavior);
    
    boolean IsMirror = (new #GameController()).GetGameMode() == "Client";
    if(IsMirror)
      _Behavior.ActivateBehavior(false);
  };

  void RemoveBehavior()
  {
    SetRadarProvider(null);

    if (null == GetBehavior())
      return;

    Component Behavior = UnregisterObject("Behavior");
    if (Behavior != null)
      shutdownComponent(Behavior);
  };

  Array SetBehRadarMask(
      Component      _Behavior,
      Component      _PropMap
    )
  {
    Array RadarMask = _PropMap.Get("BehRadarMask", [[], [], [], []]);
    int MaskSize = RadarMask.size();

    Array EnemyRestrict = [];
    if (MaskSize > 0)
    {
      if (!RadarMask[0].isEmpty())
        EnemyRestrict = RadarMask[0];
    }

    Array EnemyExclude = [];
    if (MaskSize > 1)
    {
      if (!RadarMask[1].isEmpty())
        EnemyExclude = RadarMask[1];
    }

    Array FriendRestrict = [];
    if (MaskSize > 2)
    {
      if (!RadarMask[2].isEmpty())
        FriendRestrict = RadarMask[2];
    }

    Array FriendExclude = [];
    if (MaskSize > 3)
    {
      if (!RadarMask[3].isEmpty())
        FriendsExclude = RadarMask[3];
    }

    String Affiliation = GetAffiliation();

    if (EnemyRestrict.isEmpty() && EnemyExclude.isEmpty())
    {
      if (Affiliation != "NEUTRAL")
        EnemyExclude = [ Affiliation, "NEUTRAL" ];  // if non specified use default according to affiliation
      else
        EnemyExclude = [ "ENEMY", "FRIEND", "NEUTRAL" ];
    }

    if (FriendRestrict.isEmpty() && FriendExclude.isEmpty())
    {
      FriendRestrict = [ Affiliation ];
    }

    if (-1 == FriendRestrict.find("MainMesh"))
      FriendRestrict.add("MainMesh");

    if (-1 == EnemyRestrict.find("MainMesh"))
      EnemyRestrict.add("MainMesh");

    if (_Behavior != null)
      _Behavior.SetBehRadarMask(EnemyRestrict, EnemyExclude, FriendRestrict, FriendExclude);
    else
      logWarning(getIdentificator(this) + " : empty behavior");
  }

  void EnableBehavior(
      boolean _Active,
      boolean _Init
    )
  {
    boolean IsMirror = (new #GameController()).GetGameMode() != "Server";
    // this function only for live objects
    if (!checkMask(user, [], [CLASSIFICATOR_DEAD_OBJECT]) || IsMirror)
      return;

    // get beh component
    Component Behavior = GetBehavior();
    if (Behavior != null)
    {
      // deactivate beh
      Behavior.ActivateBehavior(_Active);
    }

    // restart if needed
    if (_Init)
      Behavior.StartBehavior();

    // enable auto fire
    for (int i = 0; i < m_WeaponList.size(); i++)
      if (isFunctionExist(m_WeaponList[i], "EnableAutoFire", 1))
        m_WeaponList[i].EnableAutoFire(_Fire);

  }

  void SetBehActiveState(
      boolean _Move,
      boolean _Fire,
      boolean _Radar,
      boolean _Init
    )
  {
    // get beh component
    Component Behavior = GetBehavior();
    if (Behavior == null)
      return;

    // activate or deactivate beh
    Behavior.ActivateBehavior(_Move, _Fire, _Radar);

    // restart if needed
    if (_Init)
      Behavior.StartBehavior();

    // enable auto fire
    for (int i = 0; i < m_WeaponList.size(); i++)
      if (isFunctionExist(m_WeaponList[i], "EnableAutoFire", 1))
        m_WeaponList[i].EnableAutoFire(_Fire);
  }

  event void ShowCells(
      int _ShowCellsMode
    )
  {
    Component Behavior = GetBehavior();
    if (Behavior != null)
      Behavior.ShowCells(_ShowCellsMode);
  }

  event void ShowPath(
      int _ShowPathMode
    )
  {
    Component Behavior = GetBehavior();
    if (Behavior != null)
      Behavior.ShowPath(_ShowPathMode);
  }

  Component GetBehavior()
  {
    return GetObject("Behavior");
  }

  event void ShowKinematicsDebugInfo(
      boolean _Enable
    )
  {
    Component Behavior = GetBehavior();
    if (Behavior != null)
      Behavior.ShowKinematicsDebugInfo(_Enable);
  }

  // ======================================
  // Affiliation
  // ======================================

  void SetAffiliation(
      String _Affiliation
    )
  {
    int i = 0;

    String OldAffiliation = GetAffiliation();
    for (i = 0; i < m_WeaponList.size(); i++)
      m_WeaponList[i].ClearFriendlyGunFireMask(OldAffiliation);

    CBaseUtilities::SetAffiliation(_Affiliation);
    for (i = 0; i < m_ChildMissionObjects.size(); i++)
      m_ChildMissionObjects[i].SetAffiliation(_Affiliation);

    for (i = 0; i < m_WeaponList.size(); i++)
      m_WeaponList[i].InitMasks(_Affiliation);
  }

/*  String GetAffiliation()
  {
    Component Mission = (new #GameController()).GetMission();
    if (null == Mission)
      return "";

    Component MissionContent = Mission.GetContent();
    Array ObjectRec = MissionContent.FindObjectRecord(getIdentificator(this));

    Component Properties = new CPropertiesMap(ObjectRec[CMissionContent::INDEX_Properties]);

  
    return Properties.Get("Affiliation", "");
  }
*/
  // ======================================
  // Weapon
  // ======================================

  Array GetWeaponList()
  {
    return m_WeaponList;
  }

  void SetupWeapon(
      String    _WeaponID,
      Component _Weapon,
      Array     _Slots,
      Component _Animator
    )
  {
    SetupWeapon(_WeaponID, _Weapon, "", _Slots, _Animator);
  }

  void SetupWeapon(
      String    _WeaponID,
      Component _Weapon,
      String    _HostJoint,
      Array     _Slots,
      Component _Animator
    )
  {
    Component Mesh = GetMeshComponent();

    // Get host joint
    Component HostJoint = Mesh;
    if ("" != _HostJoint)
    {
      HostJoint = Mesh.GetJoint(_HostJoint);
      if (HostJoint == null)
      {
        logWarning("Weapon host joint " + _HostJoint + " not found");
        HostJoint = Mesh;
      }
    }

    // Setup network
    _Weapon.SetNetworkId(_WeaponID);

    // init and register weapon
    _Weapon.AttachToModel(HostJoint, GenerateJointsList(_Slots));

    m_WeaponNames.add(_WeaponID);
    m_WeaponList.add(_Weapon);
    RegisterObject(_WeaponID, _Weapon);

    // register weapon animator
    if (_Animator != null)
    {
      setPositionable(_Animator, HostJoint);
      setPositionable(_Animator, _Weapon);
      SetupAnimator("Anim" + _WeaponID, _Animator);
    }
  }

  // ======================================
  // Service
  // ======================================

  Array GenerateJointsList(
      Array _NamesList
    )
  {
    // init result
    Array Joints = [];

    // get mesh
    Component Mesh = GetMeshComponent();

    // check mesh component
    if (Mesh == null)
    {
      logError(getIdentificator(user) + ".GenerateJointsList() : Could not get Mesh object");
      return Joints;
    }

    // generate joints list
    for (int i = 0; i < _NamesList.size(); i++)
    {
      Component Joint = Mesh.GetJoint(_NamesList[i]);
      if (Joint == null)
      {
        logError("Invalid joint name " + _NamesList[i] + " in .GenerateJointsList() function call");
        Joint = Mesh;
      }

      Joints.add(Joint);
    }

    return Joints;
  }

  Matrix GetPositionOfItem(String _JointName)
  {
    if (_JointName == "")
      return getPosition(this);

    Component Mesh = GetMeshComponent();
    if (null == Mesh)
    {
      logError("Cant find mesh for get position of joint");
      return getPosition(this);
    }

    Component Joint = Mesh.GetJoint(_JointName);
    if (null == Joint)
    {
      logError("Cant find joint " + _JointName + " for create get position");
      return getPosition(this);
    }

    return getPosition(Joint);
  }

  boolean IsMirror()
  {
    return m_IsMirror;
  }

  // ======================================
  // Animator
  // ======================================

  Component GetSlaveObject()
  {
    if (isFunctionExist(this, "GetGroupObject", 0))
      return GetGroupObject();
    return GetMeshComponent();
  }

  void SetupAnimator(
      String    _ObjectID,
      Component _Animator
    )
  {
    if (null != _Animator)
    {
      setSlaveObject(_Animator, GetSlaveObject());
      RegisterObject(_ObjectID, _Animator);
    }
  }

  // ======================================
  // Menace power (how dangerous unit is)
  // ======================================

  void SetMenacePower(
      int _MenacePower
    )
  {
    UnitMenacePower = _MenacePower;
  }

  int GetMenacePower()
  {
    return UnitMenacePower;
  }

  // ==========================================
  // Interface for Editor
  // ==========================================

  // Returns current route as array of navpoint objects
  Array GetNavPath()
  {
    Array Result = [];

    Component Game = new #GameController();
    for (int i = 0; i < m_Route.size(); i++)
    {
      if (getVariableType(m_Route[i]) == ST_ARRAY)
        if (!m_Route[i].isEmpty())
          Result.add(Game.GetObject(m_Route[i][0]));
    }

    return Result;
  }

  // ======================================
  // Landing controls
  // ======================================

  Component SetupLandingControl(
      Array _GearJoints
    )
  {
    // check landing control already registered
    Component LandingControl = GetLandingControl();
    if (LandingControl != null)
      return LandingControl;

    // create and register landing control
    LandingControl = new #LandingControl();
    LandingControl.SetGearJoints(GenerateJointsList(_GearJoints));
    setSlaveObject(LandingControl, GetMeshComponent());
    RegisterObject("LandingControl", LandingControl);

    return LandingControl;
  }

  Component GetLandingControl()
  {
    return GetObject("LandingControl");
  }

  // ======================================
  // Animation controls
  // ======================================

  void LoadAnimations(
      String _script
    )
  {
    Component Mesh = GetMeshComponent();
    if (Mesh != null)
      Mesh.LoadAnimations(_script);
    else
      logError("Cant load animations. The model without mesh");
  }

  // ======================================
  // Link
  // ======================================

  void SetupObjectToObjectLink()
  {
    Component ObjectLink = new #ObjectObjectLink();
    setSlaveObject(ObjectLink, GetObject("Mesh"));
    RegisterObject("ObjectLink", ObjectLink);
  }

  void LinkObjectToObject(
      String _HostObjectID
    )
  {
    m_PointHostID  = _HostObjectID;
    m_ObjectHostID = _HostObjectID;

    Component ObjectLink = GetObject("ObjectLink");
    if (ObjectLink == null)
      return;

    Component HostObject = null;
    if (_HostObjectID != "")
      HostObject = (new #GameController()).GetObject(_HostObjectID);

    setPositionable(ObjectLink, HostObject);
  }

  // ==========================================
  //  Dialog support
  // ==========================================

  boolean DoDialog(
      Component _Dialog,
      Component _Phrase
    )
  {
    logError("CObject::DoDialog not implemented");
    _Dialog.OnPhraseCompletion(_Phrase);
    return true;
  }

  // ==========================================
  // Emitter and effect support
  // ==========================================

  void SetupSoundEmitter(
      String    _ObjectID,
      Component _Emitter
    )
  {
    RegisterObject(_ObjectID, _Emitter);

    Component EmitterLink = new #ObjectEmitterLink();
    setSlaveObject(EmitterLink, _Emitter);
    setPositionable(EmitterLink, GetMeshComponent());
    RegisterObject(_ObjectID + "Link", EmitterLink);
  }

  int AttachEffect(
      String    _HostJoint,
      String    _EffectId
    )
  {
    return AttachEffect(_HostJoint, _EffectId, new Vector(0.0), "");
  }

  int AttachEffect(
      String    _HostJoint,
      String    _EffectId,
      Vector    _Position
    )
  {
    return AttachEffect(_HostJoint, _EffectId, _Position, "");
  }

  int AttachEffect(
      String    _HostJoint,
      String    _EffectId,
      Vector    _Position,
      String    _LogicType
    )
  {
    Component Mesh = GetMeshComponent();
    if (Mesh == null)
    {
      logError(getIdentificator(user) + ".AttachEffect() : Could not get Mesh object");
      return INVALID_EFFECT_ID;
    }

    // Get host joint
    Component HostJoint = Mesh.GetJoint(_HostJoint);
    if (HostJoint == null)
      HostJoint = Mesh;

    // calculate position
    Matrix Position = getPosition(HostJoint);
    Position.origin += _Position;

    Vector BoundingSize = getBoundingSize(Mesh);
    Position.xvec *= BoundingSize.x;
    Position.yvec *= BoundingSize.y;
    Position.zvec *= BoundingSize.z;

    // Create effect and attach it
    int EffectId = (new #EffectsArray()).CreateEffect(_EffectId, Position, HostJoint);

    // store effect id
    if (INVALID_EFFECT_ID != EffectId)
    {
      Component Descr = new CEffectDescr(EffectId, _LogicType);
      m_EffectsIdList.add(Descr);
    }

    return EffectId;
  }

  int AttachEffect2(
      String    _HostJoint,
      String    _EffectId,
      Vector    _Position   // in local system coord
    )
  {
    Component Mesh = GetMeshComponent();
    if (Mesh == null)
    {
      logError(getIdentificator(user) + ".AttachEffect() : Could not get Mesh object");
      return INVALID_EFFECT_ID;
    }

    // Get host joint
    Component HostJoint = Mesh.GetJoint(_HostJoint);
    if (HostJoint == null)
      HostJoint = Mesh;

    // calculate position
    Matrix Position = getPosition(HostJoint);
    Position.origin += Position.multVec(_Position);

    Vector BoundingSize = getBoundingSize(Mesh);
    Position.xvec *= BoundingSize.x;
    Position.yvec *= BoundingSize.y;
    Position.zvec *= BoundingSize.z;

    // Create effect and attach it
    int EffectId = (new #EffectsArray()).CreateEffect(_EffectId, Position, HostJoint);

    // store effect id
    if (INVALID_EFFECT_ID != EffectId)
    {
      Component Descr = new CEffectDescr(EffectId, "");
      m_EffectsIdList.add(Descr);
    }

    return EffectId;
  }


  void EnableAllEffects(
      boolean _Enable,
      String  _Restrict,
      String  _Exclude
    )
  {
    Component EffectsArray = new #EffectsArray();
    if (EffectsArray == null)
      return;

    for (int Index = 0; Index < m_EffectsIdList.size(); Index++)
    {
      if (!m_EffectsIdList[Index].CheckMask(_Restrict, _Exclude))
        continue;

      if (m_EffectsIdList[Index].CheckMask("Light", ""))
        EffectsArray.EnableEffect(m_EffectsIdList[Index].EffectID, m_IsLightEnabled && _Enable);
      else
      {
        EffectsArray.EnableEffect(m_EffectsIdList[Index].EffectID, _Enable);
      }
    }
  }

  void SyncAnimators(
      Component _MeshDst
    )
  {
    for (int i = 0; i < m_SyncAnimators.size(); i++)
    {
      Component Animator = GetObject(m_SyncAnimators[i]);
      if (Animator == null)
      {
        logWarning(getIdentificator(user) + " cant find animator " + m_SyncAnimators[i]);
        continue;
      }
      _MeshDst.SetAnimationPhase(Animator.GetAnimationName(), Animator.GetCurrentPhase());
    }
  }

  // ==========================================
  // Object physics controller
  // ==========================================

  float ComputeTouchParams(
      float _fMass,
      float _fVelocity
    )
  {
    return 0.5f * _fMass * _fVelocity * _fVelocity;
  }

  void SetupObjectSubstance(
      Component _Substance
    )
  {
    SetupObjectSubstance(
      GetMeshComponent(),
      _Substance
    );
  }

  void SetupObjectSubstance(
      Component _Mesh,
      Component _Substance
    )
  {
    if (null != _Mesh)
    {
      Component Materials = _Mesh.GetMaterials();
      Materials.LoadDefMaterialPhysics(_Substance);
      Materials.SetDefaultSubstance(_Substance.SelfId);
    }
  }

  void SwitchTexture(
      Component _Mesh,
      String    _MaterialID,
      String    _TrgTexture
    )
  {
    Component MaterialManager = _Mesh.GetMaterials();
    if (null == MaterialManager)
      return;

    Array Materials = MaterialManager.Materials;

    for (int i = 0; i < Materials.size(); i++)
      if (Materials[i].MaterialID == _MaterialID)
      {
        //logMessage("switch " + _SrcTexture + " to " + _TrgTexture);
        MaterialManager.SetMainTexture(Materials[i].MaterialID, MaterialManager.LoadTexture(_TrgTexture));
        break;
      }
  }

  Component PreLoadTexture(
      Component _Mesh,
      String    _TrgTexture
    )
  {
    Component MaterialManager = _Mesh.GetMaterials();
    if (null == MaterialManager)
      return null;

    return MaterialManager.LoadTexture(_TrgTexture);
  }

  event void OnCinemaStart(
      String _CinemaID
    )
  {
    if (!m_ShowInCinema)
    {
      setVisibleState(GetMeshComponent(), false);
    }
  }

  event void OnCinemaStop()
  {
    if (!m_ShowInCinema)
    {
      setVisibleState(GetMeshComponent(), m_IsVisible && m_ShowInGame);
    }
  }

  void OnMoveOrder()
  {
  }

  void OnMoveOrderEnd()
  {
  }

  // ==========================================
  // Truck methods
  // ==========================================

  boolean SetupTrack(
      Component _Track
    )
  {
    Component Mesh = GetMeshComponent();
    if (Mesh != null)
    {
      setSlaveObject(_Track, Mesh );
      setPositionable(_Track, Mesh.GetJoint(_Track.JointName) );

      Component MatManager = Mesh.GetMaterials();

      Array Materials = Mesh.GetJointMaterials(_Track.JointName);

      int Index = -1;

      for (int i = 0; i < MatManager.Materials.size(); i++)
      {
        if (_Track.TrackTexName == MatManager.Materials[i].TextureName)
        {
          for (int j = 0; j < Materials.size(); j++)
          {
            if (MatManager.Materials[i].MaterialID == Materials[j])
            {
              Index = j;
              break;
            }
          }

          if (-1 != Index)
            break;
        }
      }

      if (-1 == Index)
      {
        logError("Can't find valid material for track");
        return false;
      }

      _Track.Initialize(
          MatManager,
          Materials[Index],
          _Track.TrackTexScrollScale,
          _Track.WheelAnimName,
          _Track.WheelRotateScale,
          _Track.RealTrackPathScale,
          _Track.IsLeftTrack
        );
    }

    return true;
  }

  void SetupTracks(
      Component _LeftTrack,
      Component _RightTrack
    )
  {
    if (SetupTrack(_LeftTrack))
      RegisterObject("LeftTrack",  _LeftTrack);

    if (SetupTrack(_RightTrack))
      RegisterObject("RightTrack", _RightTrack);
  }

  Component GetLeftTrack()
  {
    return GetObject("LeftTrack");
  }

  Component GetRightTrack()
  {
    return GetObject("RightTrack");
  }

  // ========================================
  // Recoil controller
  // ========================================

  void SetupRecoilController(
      Component _RecoilController
    )
  {
    setSlaveObject(_RecoilController, GetSlaveObject());
    RegisterObject("RecoilController", _RecoilController);
  }

  Component GetRecoilController()
  {
    return GetObject("RecoilController");
  }

  event void OnWeaponFire(
      Vector _Origin,
      Vector _Force
    )
  {
    Component Recoil = GetRecoilController();
    if (null != Recoil)
      Recoil.ApplyImpulse(_Force);
  }
}
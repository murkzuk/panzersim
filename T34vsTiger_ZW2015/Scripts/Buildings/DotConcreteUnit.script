//-------------------------------------------------------------------
//
//  This code is copyright 2001 by G5 Software.
//  Any unauthorized usage, either in part or in whole of this code
//  is strictly prohibited. Violators WILL be prosecuted to the
//  maximum extent allowed by law.
//
//-------------------------------------------------------------------

// Unit Explosion
class CDotConcreteUnitExplosion
  extends CBuildingExplosion
{
  float Damage = 10.0;
 // float Radius = 5.0;

  String SoundId = "BtrHanomag251AusfCMachineGunBullet";
}

/*
class CDotConcreteCrashAnimation
{
  String AnimationName = "do_crash";
  float  AnimationTime = 2.0;
} */

// Machine gun
class CDotConcreteMachineGunBulletExplosion
  extends CMachineGun127BulletExplosion
{
  float Damage = CPiercing::DzotMachineGunDamage;
}

class CDotConcreteMachineGunFakeBulletControl
  extends CMachineGunBulletControl
{
  String ExplosionId = "DotConcreteMachineGunBulletExplosion";
  Vector GravityAccel = CPiercing::BulletGravityVector;     

}

class CDotConcreteMachineGun
    extends CMachineGun
{
  final static String BulletPatternId = "DotConcreteMachineGunFakeBullet";

  final static Vector  GravityVector  = CPiercing::BulletGravityVector;
  final static boolean HighTrajectory = false;

  Component BurstFireSound = new #Emitter<CMG34MachineGunFireSound>();

  final static float FireDeviation = 0.08;

  final static float LockAngleHMin    = -30.0;
  final static float LockAngleHMax    =  30.0;
  final static float LockAngleVMin    = -15.0;
  final static float LockAngleVMax    =  15.0;
  final static float BlockedLockAngle =  1.0;

  // *** Gun parameters for behavior
  final static int FirePeriod        = 100; // ms
  final static int FirePeriodRandAdd = 50;   // ms

  final static boolean BurstFire     = true;

  final static int BurstTime         = 1400; // ms
  final static int BurstTimeRandAdd  = 1000;    // ms

  final static int BurstDelay        = 8000; // ms
  final static int BurstDelayRandAdd = 2000; // ms
  // gun specific fire mask with priorities
  final static Array GunSpecificFireMask = [
                                [["HUMAN"],   []], // high priority mask
                                [["VEHICLE"], []], // low priority mask: RestrictTo, Exclude
                                [[],          []] // low priority mask: RestrictTo, Exclude
                                           ];
}

class CDotConcreteBehavior extends CBaseGroundBehavior
{
  boolean CanMove            = false;
  boolean HasRouter          = false;
  boolean HasRadar           = true;

  // *** radar parameters
/*  Array EnemyRankDangerByDistance = [
    [[ ["HEAVYTANK"],[] ], [ [ 0.0, 200.0, 1500.0, 30.0 ], [ [400.0, 150.0] ] ] ],
    [[ ["TANK"],[] ],      [ [ 0.0, 150.0, 1500.0, 50.0 ], [ [400.0, 140.0] ] ] ], // [ Mask, PiercLinFunctionByDist]
    [[ ["ANTITANK"],[] ],  [ [ 0.0, 150.0, 1500.0, 45.0 ], [ [400.0, 130.0] ] ] ],
    [[ ["BTR"],[] ],       [ [ 0.0, 130.0, 1500.0, 30.0 ], [ [400.0, 125.0] ] ] ],
    [[ ["BLD_WAR"],[] ],   [ [ 0.0, 100.0, 1500.0, 35.0 ], [ [400.0,  80.0] ] ] ],
    [[ ["VEHICLE"],[] ],   [ [ 0.0,  10.0, 1500.0, 5.0 ],  [ [400.0,  10.0] ] ] ],
    [[ ["HUMAN"],[] ],     [ [ 0.0,  35.0, 1500.0, 2.0 ],  [ [400.0,   5.0] ] ] ]
                                    ]; // default Rank = distance if object not fit any mask
  */
  float MaxRadarDistance = 800; // m
  float MinRadarDistance = 5;   // m

  int UpdateRadarPeriod        = 3000; // ms
  int UpdateRadarPeriodRandAdd = 1000; // ms

  float AttackDistanceMin = 5.0;
  float AttackDistanceMax = 300.0;

  // *** movement physical parameters

  // physical limitations
  Vector MaxSpeed = new Vector( -1.0, 0, 0);
  //float  MinRotateRadius = 0; // unit can turn when staying

  // *** movement physical parameters

  // physical limitations

  //Vector  MaxAngleSpeed                 = new Vector(   0, 0, 1);    // [rad/s]
  //Vector  MaxAngleAccelleration         = new Vector(   0, 0, 0.5);  // [rad/(s*s)]
  //Vector  MaxAngleBrakingAccelleration  = new Vector( 0, 0, 2); //1);  // [rad/(s*s)]

  //float  MinRotateRadius = 10; // unit can turn when staying
}

class CDotConcreteUnit extends CUnit, CGroundBuilding 
 // extends   CComplexDestructibleBuilding, CGroundBuilding
 // extends
{
      String m_NormalSetId  = "NormalSet";
      String m_CrashedSetId = "CrashedSet";

  final static String BodyJoint   = "Body";

  final static String DefaultSurfaceControl = "PutonGroundLandingJoints";

  static Array LandingJoints = ["GroundLevel"];

  // Automatic classificators of this object
  final static Array AutomaticClassificators = ["GROUND", "BLD_WAR", "GER"];
  final static int    UnitMenacePower        = MENACE_NORMAL;  // light weapon
  final static float DefaultHitPoints = CHitPoints::DzotConcreteUnitHitPoints;

  static Array PrevExplosionID = [
    [ "", "USRHouseWoodExplosion" ]
                                 ];
  static Array PrevDeathEffect = [
    ["",               "BaseBuildingExplosionEffect"]
                                      ];



  // =======================================
  // Contruction and initialization
  // =======================================
  void CDotConcreteUnit()
  {
   SetupMesh(new #AnimatedObject<Cbld_DotConcreteModel>(), [0]);
    //SetupCrashAnimator(new #LineAnimator<CDotConcreteCrashAnimation>());
    // Setup Weapon  //
    SetupWeapon("Weapon1", new #Weapon<CDotConcreteMachineGun>(), ["Fire_1"], null);
    SetupWeapon("Weapon2", new #Weapon<CDotConcreteMachineGun>(), ["Fire_2"], null);
    SetupWeapon("Weapon3", new #Weapon<CDotConcreteMachineGun>(), ["Fire_3"], null);
    SetupBehavior(new #VehicleBehavior<CDotConcreteBehavior>());
    
/*     CreateCollisionControl("CBaseCollisionControl");

      Component VehicleController = CreateAIVehicleController();
      if (null == VehicleController)
      {
        logError("Cant setup type of vehicle control for " + getIdentificator(this));
        return;
      }

      RegisterObject("AIVehicleController", VehicleController);
      VehicleController.SetEventHandler(this);

      // Create mesh
      Component Mesh = GetMeshComponent();

      // Create base object
      Array BaseShapes = Mesh.GetCollisionShapes(Mesh.GetRootJoint(), false);
      Component Body = VehicleController.CreateObject(Mesh, BaseShapes);

       // Remove inside mesh because is behavior unit
      BuildOnlyOutsideMesh();
           */
  
  }

  void Construct(
      Component _Mission,
      Component _PropMap
    )
  {
    //CComplexDestructibleBuilding::Construct(_Mission, _PropMap);
    CUnit::Construct(_Mission, _PropMap);
    GetDamageHandler().SetDamageTypeModifier(CBaseExplosion::CLASSIFICATOR_DAMAGE_BULLET762792, 0.0);
    GetDamageHandler().SetDamageTypeModifier(CBaseExplosion::CLASSIFICATOR_DAMAGE_BULLET127,    0.0);

    GetDamageHandler().SetDamageTypeModifier(CBaseExplosion::CLASSIFICATOR_DAMAGE_SUBCALIBREBULLET7576, 0.1);
    GetDamageHandler().SetDamageTypeModifier(CBaseExplosion::CLASSIFICATOR_DAMAGE_SUBCALIBREBULLET85,   0.1);
    GetDamageHandler().SetDamageTypeModifier(CBaseExplosion::CLASSIFICATOR_DAMAGE_SUBCALIBREBULLET88,   0.1);


    GetDamageHandler().SetDamageTypeModifier(CBaseExplosion::CLASSIFICATOR_DAMAGE_BUILDING, 0.0);
   
/*        SetupDestroyController(
      "CWoodSubstance",
      270000.0,  // house mass
      10000,  // damage energy: more than - damage trigger
      ComputeTouchParams(30000.0, 0.0), // destroy energy: more than - destroy trigger
      [
        new CDestructibleBuildingItem("Body",           CDestructibleBuildingItem::NormalType),
        new CDestructibleBuildingItem("crashed",           CDestructibleBuildingItem::DamageType)


      ]
    );   */

  }
/*  event void OnHitPointsChanged( float v ) {
    logError( "mhp: " + new String( m_MaxHitPoints ) + " v " + new String( v ) );

    if( ( v / m_MaxHitPoints < 0.3 )) {
      SetCrashed();
    }

    }  */
}



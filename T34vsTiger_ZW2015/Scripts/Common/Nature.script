class  CNatureElements extends CBaseUtilities
{

 Component Mission()
 {
  return GetMission();
 }	
	       
 Component Object()                      
 {
 return Mission().GetObject(Mission().GetMainPlayerObjectID());
 }

 Component Atmosphere()                      
 {
 return GetMission().GetObject("Atmosphere");
 } 

 Array ModeExtends = [
      "Light",
      "Normal",
      "Hard",
      "None"
    ];

 Array Mode = [
      "Light",
      "Normal",
      "Hard"
    ];

  void Initialize(
      Component _Mission,
      Component _PropMap
    )
  {
      addClassificator(user, "NEM");
  }


 void SetStringEffect(int _mode)
 {
  if(_mode == 1)
  {
   logMessage(new String(DisplayEffectList));
    for(int i = 0; i < DisplayEffectList.size(); i++)
      {
        EffectArray.DeleteEffect(DisplayEffectList[i]);
      }
      Effect    = PrefixeEffectDefault;
  }
  else if(_mode == 2)
  {
    for(int i = 0; i < DisplayEffectList.size(); i++)
      {
        EffectArray.DeleteEffect(DisplayEffectList[i]);
      }
      Effect    = PrefixeEffectOnBinocular;
   }
 }

 void SetEffect(Matrix _Position, String _Effect)
 {
   DisplayEffectId = EffectArray.CreateEffect(_Effect, _Position, this);
   DisplayEffectList.add(DisplayEffectId);

   if(isSnow)
   {
     if(DisplayEffectList.size() >= 1)
       {
         DisplayEffectList.remove(0);
       }
   }
  
   else 
   {
     if(DisplayEffectList.size() >= 50)
       {
         DisplayEffectList.remove(49);
       }
   }
 }

 event void SetWindSequence()
 {
   Wind = true; // active la sequence de vent
   sendEvent(1.0 + rand(0.0, 5.0), "RainManager", "SetWindSequence", []); 
 }

 Vector ProdVect(Vector _Vect1, Vector _Vect2)
 {
  return new Vector(
			     _Vect1.y * _Vect2.z - _Vect1.z * _Vect2.y,
			     _Vect1.z * _Vect2.x - _Vect1.x * _Vect2.z,
			     _Vect1.x * _Vect2.y - _Vect1.y * _Vect2.x
                            );
 }

 boolean AugmentationOrientation = true;

 float WindOrientation()
 {
   float Augmentation = degreeToRadian(WindOrientationTolerance) / WindOrientationEtape;
    if(Orientation >= degreeToRadian(WindOrientation) + degreeToRadian(WindOrientationTolerance))
      {
       AugmentationOrientation = true;
      }
    if(Orientation <= degreeToRadian(WindOrientation) - degreeToRadian(WindOrientationTolerance))
      {
       AugmentationOrientation = false;
      }
    if(AugmentationOrientation)
      {
        Orientation -= Augmentation;
      }
    if(!AugmentationOrientation)
      {
        Orientation += Augmentation;
      }
     return Orientation;
 }

 float WindAngle()
 {
   if(Wind)
     {
       if(AngleWindCrecsendo <= 0.0)//la fin de l'operation retourne un nombre negatif
         {
  	   AugmentationAngle = true;
  	   Wind = false;
  	   AngleWind = degreeToRadian(rand(WindAngle, WindAngle - WindAngle / 10));
  	   NbEtapeWind = rand(WindEtape, WindEtape - WindEtape / 10);
 	 }

       if(AngleWindCrecsendo >= AngleWind)
 	 {
  	   AugmentationAngle = false;
 	 }

       if(AugmentationAngle)
 	 {
  	   AngleWindCrecsendo += AngleWind / NbEtapeWind;
 	 }

       if(!AugmentationAngle)
 	 {
  	   AngleWindCrecsendo -= (AngleWind - 0.001) / NbEtapeWind;
 	 }
      return AngleWindCrecsendo;
     }
     else 
       {
  	 return 0.0;
       }
 }

 variant GetStaticEffectVariable(String _Variable)
 {
  if(isClassExist("C" + Effect + EffectMode))
    {
     return getStaticClassMember("C" + Effect + EffectMode, _Variable);
    }
  else 
    {
     WriteLog("EffectVariable", "C" + Effect + EffectMode + " doesn't exist, can't get variable " + _Variable, 2);//la classe n'existe pas
    } 

 }

 static void WriteLog(String _User, String _Texte, int _Color)
 {
     Array Colors = ["#7f7f7f", "#ffff00", "#ff0000"];
     String ColorWrite = Colors[_Color]; 

     String Write = loadStringFromFile("rain.log");

     saveStringToFile("rain.log", Write);
 }

 void LogMessage(String name, String Texte)
 {
    WriteLog(name, Texte, 0);
 } /* */
}
